<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[张大伟的个人博客]]></title>
  <subtitle><![CDATA[strucoder's blog]]></subtitle>
  <link href="/atom.xml" rel="self"/>
  <link href="http://strucoder.com/"/>
  <updated>2015-11-26T02:07:22.000Z</updated>
  <id>http://strucoder.com/</id>
  
  <author>
    <name><![CDATA[David Zhang]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[编程智慧]]></title>
    <link href="http://strucoder.com/2015/11/26/%E7%BC%96%E7%A8%8B%E6%99%BA%E6%85%A7/"/>
    <id>http://strucoder.com/2015/11/26/编程智慧/</id>
    <published>2015-11-26T01:53:11.000Z</published>
    <updated>2015-11-26T02:07:22.000Z</updated>
    <content type="html"><![CDATA[<p>文章转自: <a href="http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy/" target="_blank" rel="external">yinwang</a><br>编程是创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而我希望它能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。</p>
<a id="more"></a>
<h2 id="反复推敲代码">反复推敲代码</h2><p>既然“天才是百分之一的灵感，百分之九十九的汗水”，那我先来谈谈这汗水的部分吧。有人问我，提高编程水平最有效的办法是什么？我想了很久，终于发现最有效的办法，其实是反反复复地修改和推敲代码。</p>
<p>在IU的时候，由于Dan Friedman的严格教导，我们以写出冗长复杂的代码为耻。如果你代码多写了几行，这老顽童就会大笑，说：“当年我解决这个问题，只写了5行代码，你回去再想想吧……” 当然，有时候他只是夸张一下，故意刺激你的，其实没有人能只用5行代码完成。然而这种提炼代码，减少冗余的习惯，却由此深入了我的骨髓。</p>
<p>有些人喜欢炫耀自己写了多少多少万行的代码，仿佛代码的数量是衡量编程水平的标准。然而，如果你总是匆匆写出代码，却从来不回头去推敲，修改和提炼，其实是不可能提高编程水平的。你会制造出越来越多平庸甚至糟糕的代码。在这种意义上，很多人所谓的“工作经验”，跟他代码的质量，其实不一定成正比。如果有几十年的工作经验，却从来不回头去提炼和反思自己的代码，那么他也许还不如一个只有一两年经验，却喜欢反复推敲，仔细领悟的人。</p>
<p>有位文豪说得好：“看一个作家的水平，不是看他发表了多少文字，而要看他的废纸篓里扔掉了多少。” 我觉得同样的理论适用于编程。好的程序员，他们删掉的代码，比留下来的还要多很多。如果你看见一个人写了很多代码，却没有删掉多少，那他的代码一定有很多垃圾。</p>
<p>就像文学作品一样，代码是不可能一蹴而就的。灵感似乎总是零零星星，陆陆续续到来的。任何人都不可能一笔呵成，就算再厉害的程序员，也需要经过一段时间，才能发现最简单优雅的写法。有时候你反复提炼一段代码，觉得到了顶峰，没法再改进了，可是过了几个月再回头来看，又发现好多可以改进和简化的地方。这跟写文章一模一样，回头看几个月或者几年前写的东西，你总能发现一些改进。</p>
<p>所以如果反复提炼代码已经不再有进展，那么你可以暂时把它放下。过几个星期或者几个月再回头来看，也许就有焕然一新的灵感。这样反反复复很多次之后，你就积累起了灵感和智慧，从而能够在遇到新问题的时候直接朝正确，或者接近正确的方向前进。</p>
<h2 id="写优雅的代码">写优雅的代码</h2><p>人们都讨厌“面条代码”（spaghetti code），因为它就像面条一样绕来绕去，没法理清头绪。那么优雅的代码一般是什么形状的呢？经过多年的观察，我发现优雅的代码，在形状上有一些明显的特征。</p>
<p>如果我们忽略具体的内容，从大体结构上来看，优雅的代码看起来就像是一些整整齐齐，套在一起的盒子。如果跟整理房间做一个类比，就很容易理解。如果你把所有物品都丢在一个很大的抽屉里，那么它们就会全都混在一起。你就很难整理，很难迅速的找到需要的东西。但是如果你在抽屉里再放几个小盒子，把物品分门别类放进去，那么它们就不会到处乱跑，你就可以比较容易的找到和管理它们。</p>
<p>优雅的代码的另一个特征是，它的逻辑大体上看起来，是枝丫分明的树状结构（tree）。这是因为程序所做的几乎一切事情，都是信息的传递和分支。你可以把代码看成是一个电路，电流经过导线，分流或者汇合。如果你是这样思考的，你的代码里就会比较少出现只有一个分支的if语句，它看起来就会像这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意到了吗？在我的代码里面，if语句几乎总是有两个分支。它们有可能嵌套，有多层的缩进，而且else分支里面有可能出现少量重复的代码。然而这样的结构，逻辑却非常严密和清晰。在后面我会告诉你为什么if语句最好有两个分支。</p>
<h2 id="写模块化的代码">写模块化的代码</h2><p>有些人吵着闹着要让程序“模块化”，结果他们的做法是把代码分部到多个文件和目录里面，然后把这些目录或者文件叫做“module”。他们甚至把这些目录分放在不同的VCS repo里面。结果这样的作法并没有带来合作的流畅，而是带来了许多的麻烦。这是因为他们其实并不理解什么叫做“模块”，肤浅的把代码切割开来，分放在不同的位置，其实非但不能达到模块化的目的，而且制造了不必要的麻烦。</p>
<p>真正的模块化，并不是文本意义上的，而是逻辑意义上的。一个模块应该像一个电路芯片，它有定义良好的输入和输出。实际上一种很好的模块化方法早已经存在，它的名字叫做“函数”。每一个函数都有明确的输入（参数）和输出（返回值），同一个文件里可以包含多个函数，所以你其实根本不需要把代码分开在多个文件或者目录里面，同样可以完成代码的模块化。我可以把代码全都写在同一个文件里，却仍然是非常模块化的代码。</p>
<p>想要达到很好的模块化，你需要做到以下几点：</p>
<p>避免写太长的函数。如果发现函数太大了，就应该把它拆分成几个更小的。通常我写的函数长度都不超过40行。对比一下，一般笔记本电脑屏幕所能容纳的代码行数是50行。我可以一目了然的看见一个40行的函数，而不需要滚屏。只有40行而不是50行的原因是，我的眼球不转的话，最大的视角只看得到40行代码。</p>
<p>如果我看代码不转眼球的话，我就能把整片代码完整的映射到我的视觉神经里，这样就算忽然闭上眼睛，我也能看得见这段代码。我发现闭上眼睛的时候，大脑能够更加有效地处理代码，你能想象这段代码可以变成什么其它的形状。40行并不是一个很大的限制，因为函数里面比较复杂的部分，往往早就被我提取出去，做成了更小的函数，然后从原来的函数里面调用。</p>
<p>制造小的工具函数。如果你仔细观察代码，就会发现其实里面有很多的重复。这些常用的代码，不管它有多短，提取出去做成函数，都可能是会有好处的。有些帮助函数也许就只有两行，然而它们却能大大简化主要函数里面的逻辑。</p>
<p>有些人不喜欢使用小的函数，因为他们想避免函数调用的开销，结果他们写出几百行之大的函数。这是一种历史遗留的错觉。现代的编译器都能自动的把小的函数内联（inline）到调用它的地方，所以根本不产生函数调用，也就不会产生任何多余的开销。</p>
<p>同样的一些人，也爱使用宏（macro）来代替小函数，这也是一种历史遗留的错觉。在早期的C语言编译器里，只有macro是静态“内联”的，所以他们使用宏，其实是为了达到内联的目的。然而能否内联，其实并不是宏与函数的根本区别。宏与函数有着巨大的区别（这个我以后再讲），应该尽量避免使用宏。为了内联而使用宏，其实是滥用了宏，这会引起各种各样的麻烦，比如使程序难以理解，难以调试，容易出错等等。</p>
<p>每个函数只做一件简单的事情。有些人喜欢制造一些“通用”的函数，既可以做这个又可以做那个，它的内部依据某些变量和条件，来“选择”这个函数所要做的事情。比如，你也许写出这样的函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  <span class="keyword">if</span> (getOS().equals(<span class="string">"MacOS"</span>)) &#123;</span><br><span class="line">    a();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b();</span><br><span class="line">  &#125;</span><br><span class="line">  c();</span><br><span class="line">  <span class="keyword">if</span> (getOS().equals(<span class="string">"MacOS"</span>)) &#123;</span><br><span class="line">    d();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    e();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写这个函数的人，根据系统是否为“MacOS”来做不同的事情。你可以看出这个函数里，其实只有c()是两种系统共有的，而其它的a(), b(), d(), e()都属于不同的分支。</p>
<p>这种“复用”其实是有害的。如果一个函数可能做两种事情，它们之间共同点少于它们的不同点，那你最好就写两个不同的函数，否则这个函数的逻辑就不会很清晰，容易出现错误。其实，上面这个函数可以改写成两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMacOS() &#123;</span><br><span class="line">  a();</span><br><span class="line">  c();</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fooOther() &#123;</span><br><span class="line">  b();</span><br><span class="line">  c();</span><br><span class="line">  e();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果你发现两件事情大部分内容相同，只有少数不同，多半时候你可以把相同的部分提取出去，做成一个辅助函数。比如，如果你有个函数是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> foo() &#123;</span><br><span class="line">  a();</span><br><span class="line">  b()</span><br><span class="line">  c();</span><br><span class="line">  <span class="keyword">if</span> (getOS().equals(<span class="string">"MacOS"</span>)) &#123;</span><br><span class="line">    d();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    e();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>其中a()，b()，c()都是一样的，只有d()和e()根据系统有所不同。那么你可以把a()，b()，c()提取出去：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> preFoo() &#123;</span><br><span class="line">  a();</span><br><span class="line">  b()</span><br><span class="line">  c();</span><br></pre></td></tr></table></figure></p>
<p>然后制造两个函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fooMacOS() &#123;</span><br><span class="line">  preFoo();</span><br><span class="line">  d();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> fooOther() &#123;</span><br><span class="line">  preFoo();</span><br><span class="line">  e();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样一来，我们既共享了代码，又做到了每个函数只做一件简单的事情。这样的代码，逻辑就更加清晰。</p>
<h2 id="写可读的代码">写可读的代码</h2><p>有些人以为写很多注释就可以让代码更加可读，然而却发现事与愿违。注释不但没能让代码变得可读，反而由于大量的注释充斥在代码中间，让程序变得障眼难读。而且代码的逻辑一旦修改，就会有很多的注释变得过时，需要更新。修改注释是相当大的负担，所以大量的注释，反而成为了妨碍改进代码的绊脚石。</p>
<p>实际上，真正优雅可读的代码，是几乎不需要注释的。如果你发现需要写很多注释，那么你的代码肯定是含混晦涩，逻辑不清晰的。其实，程序语言相比自然语言，是更加强大而严谨的，它其实具有自然语言最主要的元素：主语，谓语，宾语，名词，动词，如果，那么，否则，是，不是，…… 所以如果你充分利用了程序语言的表达能力，你完全可以用程序本身来表达它到底在干什么，而不需要自然语言的辅助。</p>
<p>有少数的时候，你也许会为了绕过其他一些代码的设计问题，采用一些违反直觉的作法。这时候你可以使用很短注释，说明为什么要写成那奇怪的样子。这样的情况应该少出现，否则这意味着整个代码的设计都有问题。</p>
<p>如果没能合理利用程序语言提供的优势，你会发现程序还是很难懂，以至于需要写注释。所以我现在告诉你一些要点，也许可以帮助你大大减少写注释的必要：</p>
<p>使用有意义的函数和变量名字。如果你的函数和变量的名字，能够切实的描述它们的逻辑，那么你就不需要写注释来解释它在干什么。比如：</p>
<p>// put elephant elephant1 into fridge fridge2<br>putElephantIntoFridge(elephant1, fridge2);<br>由于我的函数名putElephantIntoFridge已经说明了它要干什么（把大象放进冰箱），所以上面那句注释完全没有必要。</p>
<p>把复杂的逻辑提取出去，做成“帮助函数”。有些人写的函数很长，以至于看不清楚里面的语句在干什么，所以他们误以为需要写注释。如果你仔细观察这些代码，就会发现不清晰的那片代码，往往可以被提取出去，做成一个函数，然后在原来的地方调用。由于函数有一个名字，这样你就可以使用有意义的函数名来代替注释。举一个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line"><span class="comment">// put elephant elephant1 into fridge fridge2</span></span><br><span class="line">openDoor(fridge2);</span><br><span class="line"><span class="keyword">if</span> (driveElephantIntoFridge(elephan1, fridge2)) &#123;</span><br><span class="line">   feedElephant(<span class="keyword">new</span> Treat(), elephant1);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   putBananaIntoFridge(<span class="keyword">new</span> Banana(), fridge2);</span><br><span class="line">   waitForElephantEnter(elephant1, fridge2);</span><br><span class="line">&#125;</span><br><span class="line">closeDoor(fridge2);</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>如果你把这片代码提出去定义成一个函数：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">putElephantIntoFridge</span>(<span class="params">elephant, fridge</span>) </span>&#123;</span><br><span class="line">  openDoor(fridge2);</span><br><span class="line">  <span class="keyword">if</span> (driveElephantIntoFridge(elephan1, fridge2)) &#123;</span><br><span class="line">    feedElephant(<span class="keyword">new</span> Treat(), elephant1);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    putBananaIntoFridge(<span class="keyword">new</span> Banana(), fridge2);</span><br><span class="line">    waitForElephantEnter(elephant1, fridge2);</span><br><span class="line">  &#125;</span><br><span class="line">  closeDoor(fridge2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>然后原来的代码就可以改成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">... ...</span><br><span class="line">... ...</span><br><span class="line"></span><br><span class="line">putElephantIntoFridge(elephant1, fridge2);</span><br><span class="line"></span><br><span class="line">... ...</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure></p>
<p>注释就没必要了。</p>
<p>把复杂的表达式提取出去，做成中间变量。有些人听说“函数式编程”是个好东西，也不理解它的真正含义，就在代码里使用大量嵌套的函数。像这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Pizza pizza = makePizza(crust(salt(), butter()),</span><br><span class="line">   topping(onion(), tomato(), sausage()));</span><br></pre></td></tr></table></figure></p>
<p>这样的代码一行太长，而且嵌套太多，不容易看清楚。其实训练有素的函数式程序员，都知道中间变量的好处，不会盲目的使用嵌套的函数。他们会把这代码变成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Crust crust = crust(salt(), butter());</span><br><span class="line">Topping topping = topping(onion(), tomato(), sausage());</span><br><span class="line">Pizza pizza = makePizza(crust, topping);</span><br></pre></td></tr></table></figure></p>
<p>这样写，不但有效地控制了单行代码的长度，而且由于引入的中间变量具有“意义”，步骤清晰，变得很容易理解。</p>
<p>说到这里，我必须警告你，这里所说的“不需注释，让代码自己解释自己”，并不是说要让代码看起来像某种自然语言。有个叫Chai的JavaScript测试工具，可以让你这样写代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">expect(foo).to.be.a(<span class="string">'string'</span>);</span><br><span class="line">expect(foo).to.equal(<span class="string">'bar'</span>);</span><br><span class="line">expect(foo).to.have.length(<span class="number">3</span>);</span><br><span class="line">expect(tea).to.have.property(<span class="string">'flavors'</span>).with.length(<span class="number">3</span>);</span><br></pre></td></tr></table></figure></p>
<p>这种做法是极其错误的。程序语言本来就比自然语言简单清晰，这种写法让它看起来像自然语言的样子，反而变得复杂难懂了。</p>
<h2 id="写简单的代码">写简单的代码</h2><p>程序语言都喜欢标新立异，提供这样那样的“特性”，然而有些特性其实并不是什么好东西。很多特性都经不起时间的考验，最后带来的麻烦，比解决的问题还多。很多人盲目的追求“短小”和“精悍”，或者为了显示自己头脑聪明，学得快，所以喜欢利用语言里的一些特殊构造，写出过于“聪明”，难以理解的代码。</p>
<p>并不是语言提供什么，你就一定要把它用上的。实际上你只需要其中很小的一部分功能，就能写出优秀的代码。我一向反对“充分利用”程序语言里的所有特性。实际上，我心目中有一套最好的构造。不管语言提供了多么“神奇”的，“新”的特性，我基本都只用经过千锤百炼，我觉得值得信奈的那一套。</p>
<p>现在针对一些有问题的语言特性，我介绍一些我自己使用的代码规范，并且讲解一下为什么它们能让代码更简单。</p>
<p>避免使用自增减表达式（i++，++i，i–，–i）。这种自增减操作表达式其实是历史遗留的设计失误。它们含义蹊跷，非常容易弄错。它们把读和写这两种完全不同的操作，混淆缠绕在一起，把语义搞得乌七八糟。含有它们的表达式，结果可能取决于求值顺序，所以它可能在某种编译器下能正确运行，换一个编译器就出现离奇的错误。</p>
<p>其实这两个表达式完全可以分解成两步，把读和写分开：一步更新i的值，另外一步使用i的值。比如，如果你想写foo(i++)，你完全可以把它拆成int t = i; i += 1; foo(t);。如果你想写foo(++i)，可以拆成i += 1; foo(i); 拆开之后的代码，含义完全一致，却清晰很多。到底更新是在取值之前还是之后，一目了然。</p>
<p>有人也许以为i++或者++i的效率比拆开之后要高，这只是一种错觉。这些代码经过基本的编译器优化之后，生成的机器代码是完全没有区别的。自增减表达式只有在两种情况下才可以安全的使用。一种是在for循环的update部分，比如for(int i = 0; i &lt; 5; i++)。另一种情况是写成单独的一行，比如i++;。这两种情况是完全没有歧义的。你需要避免其它的情况，比如用在复杂的表达式里面，比如foo(i++)，foo(++i) + foo(i)，…… 没有人应该知道，或者去追究这些是什么意思。</p>
<p>永远不要省略花括号。很多语言允许你在某种情况下省略掉花括号，比如C，Java都允许你在if语句里面只有一句话的时候省略掉花括号：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">  action1();</span><br></pre></td></tr></table></figure></p>
<p>咋一看少打了两个字，多好。可是这其实经常引起奇怪的问题。比如，你后来想要加一句话action2()到这个if里面，于是你就把代码改成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...)</span><br><span class="line">  action1();</span><br><span class="line">  action2();</span><br></pre></td></tr></table></figure></p>
<p>为了美观，你很小心的使用了action1()的缩进。咋一看它们是在一起的，所以你下意识里以为它们只会在if的条件为真的时候执行，然而action2()却其实在if外面，它会被无条件的执行。我把这种现象叫做“光学幻觉”（optical illusion），理论上每个程序员都应该发现这个错误，然而实际上却容易被忽视。</p>
<p>那么你问，谁会这么傻，我在加入action2()的时候加上花括号不就行了？可是从设计的角度来看，这样其实并不是合理的作法。首先，也许你以后又想把action2()去掉，这样你为了样式一致，又得把花括号拿掉，烦不烦啊？其次，这使得代码样式不一致，有的if有花括号，有的又没有。况且，你为什么需要记住这个规则？如果你不问三七二十一，只要是if-else语句，把花括号全都打上，就可以想都不用想了，就当C和Java没提供给你这个特殊写法。这样就可以保持完全的一致性，减少不必要的思考。</p>
<p>有人可能会说，全都打上花括号，只有一句话也打上，多碍眼啊？然而经过实行这种编码规范几年之后，我并没有发现这种写法更加碍眼，反而由于花括号的存在，使得代码界限明确，让我的眼睛负担更小了。</p>
<p>合理使用括号，不要盲目依赖操作符优先级。利用操作符的优先级来减少括号，对于1 + 2 <em> 3这样常见的算数表达式，是没问题的。然而有些人如此的仇恨括号，以至于他们会写出2 &lt;&lt; 7 - 2 </em> 3这样的表达式，而完全不用括号。</p>
<p>这里的问题，在于移位操作&lt;&lt;的优先级，是很多人不熟悉，而且是违反常理的。由于x &lt;&lt; 1相当于把x乘以2，很多人误以为这个表达式相当于(2 &lt;&lt; 7) - (2 <em> 3)，所以等于250。然而实际上&lt;&lt;的优先级比加法+还要低，所以这表达式其实相当于2 &lt;&lt; (7 - 2 </em> 3)，所以等于4！</p>
<p>解决这个问题的办法，不是要每个人去把操作符优先级表给硬背下来，而是合理的加入括号。比如上面的例子，最好直接加上括号写成2 &lt;&lt; (7 - 2 * 3)。虽然没有括号也表示同样的意思，但是加上括号就更加清晰，读者不再需要死记&lt;&lt;的优先级就能理解代码。</p>
<p>避免使用continue和break。循环语句（for，while）里面出现return是没问题的，然而如果你使用了continue或者break，就会让循环的逻辑和终止条件变得复杂，难以确保正确。</p>
<p>出现continue或者break的原因，往往是对循环的逻辑没有想清楚。如果你考虑周全了，应该是几乎不需要continue或者break的。如果你的循环里出现了continue或者break，你就应该考虑改写这个循环。改写循环的办法有多种：</p>
<p>如果出现了continue，你往往只需要把continue的条件反向，就可以消除continue。<br>如果出现了break，你往往可以把break的条件，合并到循环头部的终止条件里，从而去掉break。<br>有时候你可以把break替换成return，从而去掉break。<br>如果以上都失败了，你也许可以把循环里面复杂的部分提取出来，做成函数调用，之后continue或者break就可以去掉了。<br>下面我对这些情况举一些例子。</p>
<p>情况1：下面这段代码里面有一个continue：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; goodNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> name: names) &#123;</span><br><span class="line">  <span class="keyword">if</span> (name.contains(<span class="string">"bad"</span>)) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  goodNames.add(name);</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>它说：“如果name含有’bad’这个词，跳过后面的循环代码……” 注意，这是一种“负面”的描述，它不是在告诉你什么时候“做”一件事，而是在告诉你什么时候“不做”一件事。为了知道它到底在干什么，你必须搞清楚continue会导致哪些语句被跳过了，然后脑子里把逻辑反个向，你才能知道它到底想做什么。这就是为什么含有continue和break的循环不容易理解，它们依靠“控制流”来描述“不做什么”，“跳过什么”，结果到最后你也没搞清楚它到底“要做什么”。</p>
<p>其实，我们只需要把continue的条件反向，这段代码就可以很容易的被转换成等价的，不含continue的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">List&lt;<span class="built_in">String</span>&gt; goodNames = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">String</span> name: names) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!name.contains(<span class="string">"bad"</span>)) &#123;</span><br><span class="line">    goodNames.add(name);</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>goodNames.add(name);和它之后的代码全部被放到了if里面，多了一层缩进，然而continue却没有了。你再读这段代码，就会发现更加清晰。因为它是一种更加“正面”地描述。它说：“在name不含有’bad’这个词的时候，把它加到goodNames的链表里面……”</p>
<p>情况2：for和while头部都有一个循环的“终止条件”，那本来应该是这个循环唯一的退出条件。如果你在循环中间有break，它其实给这个循环增加了一个退出条件。你往往只需要把这个条件合并到循环头部，就可以去掉break。</p>
<p>比如下面这段代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition1) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">if</span> (condition2) &#123;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当condition成立的时候，break会退出循环。其实你只需要把condition2反转之后，放到while头部的终止条件，就可以去掉这种break语句。改写后的代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (condition1 &amp;&amp; !condition2) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种情况表面上貌似只适用于break出现在循环开头或者末尾的时候，然而其实大部分时候，break都可以通过某种方式，移动到循环的开头或者末尾。具体的例子我暂时没有，等出现的时候再加进来。</p>
<p>情况3：很多break退出循环之后，其实接下来就是一个return。这种break往往可以直接换成return。比如下面这个例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasBadName(List&lt;<span class="built_in">String</span>&gt; names) &#123;</span><br><span class="line">    boolean result = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">String</span> name: names) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.contains(<span class="string">"bad"</span>)) &#123;</span><br><span class="line">            result = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数检查names链表里是否存在一个名字，包含“bad”这个词。它的循环里包含一个break语句。这个函数可以被改写成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasBadName(List&lt;<span class="built_in">String</span>&gt; names) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">String</span> name: names) &#123;</span><br><span class="line">        <span class="keyword">if</span> (name.contains(<span class="string">"bad"</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>改进后的代码，在name里面含有“bad”的时候，直接用return true返回，而不是对result变量赋值，break出去，最后才返回。如果循环结束了还没有return，那就返回false，表示没有找到这样的名字。使用return来代替break，这样break语句和result这个变量，都一并被消除掉了。</p>
<p>我曾经见过很多其他使用continue和break的例子，几乎无一例外的可以被消除掉，变换后的代码变得清晰很多。我的经验是，99%的break和continue，都可以通过替换成return语句，或者翻转if条件的方式来消除掉。剩下的1%含有复杂的逻辑，但也可以通过提取一个帮助函数来消除掉。修改之后的代码变得容易理解，容易确保正确。</p>
<h2 id="写直观的代码">写直观的代码</h2><p>我写代码有一条重要的原则：如果有更加直接，更加清晰的写法，就选择它，即使它看起来更长，更笨，也一样选择它。比如，Unix命令行有一种“巧妙”的写法是这样：</p>
<p><code>command1 &amp;&amp; command2 &amp;&amp; command3</code><br>由于Shell语言的逻辑操作a &amp;&amp; b具有“短路”的特性，如果a等于false，那么b就没必要执行了。这就是为什么当command1成功，才会执行command2，当command2成功，才会执行command3。同样，</p>
<p><code>command1 || command2 || command3</code><br>操作符||也有类似的特性。上面这个命令行，如果command1成功，那么command2和command3都不会被执行。如果command1失败，command2成功，那么command3就不会被执行。</p>
<p>这比起用if语句来判断失败，似乎更加巧妙和简洁，所以有人就借鉴了这种方式，在程序的代码里也使用这种方式。比如他们可能会写这样的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (action1() || action2() &amp;&amp; action3()) &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>你看得出来这代码是想干什么吗？action2和action3什么条件下执行，什么条件下不执行？也许稍微想一下，你知道它在干什么：“如果action1失败了，执行action2，如果action2成功了，执行action3”。然而那种语义，并不是直接的“映射”在这代码上面的。比如“失败”这个词，对应了代码里的哪一个字呢？你找不出来，因为它包含在了||的语义里面，你需要知道||的短路特性，以及逻辑或的语义才能知道这里面在说“如果action1失败……”。每一次看到这行代码，你都需要思考一下，这样积累起来的负荷，就会让人很累。</p>
<p>其实，这种写法是滥用了逻辑操作&amp;&amp;和||的短路特性。这两个操作符可能不执行右边的表达式，原因是为了机器的执行效率，而不是为了给人提供这种“巧妙”的用法。这两个操作符的本意，只是作为逻辑操作，它们并不是拿来给你代替if语句的。也就是说，它们只是碰巧可以达到某些if语句的效果，但你不应该因此就用它来代替if语句。如果你这样做了，就会让代码晦涩难懂。</p>
<p>上面的代码写成笨一点的办法，就会清晰很多：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!action1()) &#123;</span><br><span class="line">  <span class="keyword">if</span> (action2()) &#123;</span><br><span class="line">    action3();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里我很明显的看出这代码在说什么，想都不用想：如果action1()失败了，那么执行action2()，如果action2()成功了，执行action3()。你发现这里面的一一对应关系吗？if=如果，!=失败，…… 你不需要利用逻辑学知识，就知道它在说什么。</p>
<h2 id="写无懈可击的代码">写无懈可击的代码</h2><p>在之前一节里，我提到了自己写的代码里面很少出现只有一个分支的if语句。我写出的if语句，大部分都有两个分支，所以我的代码很多看起来是这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>使用这种方式，其实是为了无懈可击的处理所有可能出现的情况，避免漏掉corner case。每个if语句都有两个分支的理由是：如果if的条件成立，你做某件事情；但是如果if的条件不成立，你应该知道要做什么另外的事情。不管你的if有没有else，你终究是逃不掉，必须得思考这个问题的。</p>
<p>很多人写if语句喜欢省略else的分支，因为他们觉得有些else分支的代码重复了。比如我的代码里，两个else分支都是return true。为了避免重复，他们省略掉那两个else分支，只在最后使用一个return true。这样，缺了else分支的if语句，控制流自动“掉下去”，到达最后的return true。他们的代码看起来像这个样子：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (...) &#123;</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br></pre></td></tr></table></figure></p>
<p>这种写法看似更加简洁，避免了重复，然而却很容易出现疏忽和漏洞。嵌套的if语句省略了一些else，依靠语句的“控制流”来处理else的情况，是很难正确的分析和推理的。如果你的if条件里使用了&amp;&amp;和||之类的逻辑运算，就更难看出是否涵盖了所有的情况。</p>
<p>由于疏忽而漏掉的分支，全都会自动“掉下去”，最后返回意想不到的结果。即使你看一遍之后确信是正确的，每次读这段代码，你都不能确信它照顾了所有的情况，又得重新推理一遍。这简洁的写法，带来的是反复的，沉重的头脑开销。这就是所谓“面条代码”，因为程序的逻辑分支，不是像一棵枝叶分明的树，而是像面条一样绕来绕去。</p>
<p>另外一种省略else分支的情况是这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s = <span class="string">""</span>;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  s = <span class="string">"ok"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>写这段代码的人，脑子里喜欢使用一种“缺省值”的做法。s缺省为null，如果x&lt;5，那么把它改变（mutate）成“ok”。这种写法的缺点是，当x&lt;5不成立的时候，你需要往上面看，才能知道s的值是什么。这还是你运气好的时候，因为s就在上面不远。很多人写这种代码的时候，s的初始值离判断语句有一定的距离，中间还有可能插入一些其它的逻辑和赋值操作。这样的代码，把变量改来改去的，看得人眼花，就容易出错。</p>
<p>现在比较一下我的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> s;</span><br><span class="line"><span class="keyword">if</span> (x &lt; <span class="number">5</span>) &#123;</span><br><span class="line">  s = <span class="string">"ok"</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  s = <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这种写法貌似多打了一两个字，然而它却更加清晰。这是因为我们明确的指出了x&lt;5不成立的时候，s的值是什么。它就摆在那里，它是””（空字符串）。注意，虽然我也使用了赋值操作，然而我并没有“改变”s的值。s一开始的时候没有值，被赋值之后就再也没有变过。我的这种写法，通常被叫做更加“函数式”，因为我只赋值一次。</p>
<p>如果我漏写了else分支，Java编译器是不会放过我的。它会抱怨：“在某个分支，s没有被初始化。”这就强迫我清清楚楚的设定各种条件下s的值，不漏掉任何一种情况。</p>
<p>当然，由于这个情况比较简单，你还可以把它写成这样：<br><figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String </span>s = x &lt; <span class="number">5</span> ? <span class="string">"ok"</span> : <span class="string">""</span><span class="comment">;</span></span><br></pre></td></tr></table></figure></p>
<p>对于更加复杂的情况，我建议还是写成if语句为好。</p>
<h2 id="正确处理错误">正确处理错误</h2><p>使用有两个分支的if语句，只是我的代码可以达到无懈可击的其中一个原因。这样写if语句的思路，其实包含了使代码可靠的一种通用思想：穷举所有的情况，不漏掉任何一个。</p>
<p>程序的绝大部分功能，是进行信息处理。从一堆纷繁复杂，模棱两可的信息中，排除掉绝大部分“干扰信息”，找到自己需要的那一个。正确地对所有的“可能性”进行推理，就是写出无懈可击代码的核心思想。这一节我来讲一讲，如何把这种思想用在错误处理上。</p>
<p>错误处理是一个古老的问题，可是经过了几十年，还是很多人没搞明白。Unix的系统API手册，一般都会告诉你可能出现的返回值和错误信息。比如，Linux的read系统调用手册里面有如下内容：</p>
<blockquote>
<p> s<br>RETURN VALUE<br>On success, the number of bytes read is returned…<br>On error, -1 is returned, and errno is set appropriately.<br>ERRORS<br>EAGAIN, EBADF, EFAULT, EINTR, EINVAL, …</p>
</blockquote>
<p>很多初学者，都会忘记检查read的返回值是否为-1，觉得每次调用read都得检查返回值真繁琐，不检查貌似也相安无事。这种想法其实是很危险的。如果函数的返回值告诉你，要么返回一个正数，表示读到的数据长度，要么返回-1，那么你就必须要对这个-1作出相应的，有意义的处理。千万不要以为你可以忽视这个特殊的返回值，因为它是一种“可能性”。代码漏掉任何一种可能出现的情况，都可能产生意想不到的灾难性结果。</p>
<p>对于Java来说，这相对方便一些。Java的函数如果出现问题，一般通过异常（exception）来表示。你可以把异常加上函数本来的返回值，看成是一个“union类型”。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> foo() throws MyException &#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这里MyException是一个错误返回。你可以认为这个函数返回一个union类型：{String, MyException}。任何调用foo的代码，必须对MyException作出合理的处理，才有可能确保程序的正确运行。Union类型是一种相当先进的类型，目前只有极少数语言（比如Typed Racket）具有这种类型，我在这里提到它，只是为了方便解释概念。掌握了概念之后，你其实可以在头脑里实现一个union类型系统，这样使用普通的语言也能写出可靠的代码。</p>
<p>由于Java的类型系统强制要求函数在类型里面声明可能出现的异常，而且强制调用者处理可能出现的异常，所以基本上不可能出现由于疏忽而漏掉的情况。但有些Java程序员有一种恶习，使得这种安全机制几乎完全失效。每当编译器报错，说“你没有catch这个foo函数可能出现的异常”时，有些人想都不想，直接把代码改成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>或者最多在里面放个log，或者干脆把自己的函数类型上加上throws Exception，这样编译器就不再抱怨。这些做法貌似很省事，然而都是错误的，你终究会为此付出代价。</p>
<p>如果你把异常catch了，忽略掉，那么你就不知道foo其实失败了。这就像开车时看到路口写着“前方施工，道路关闭”，还继续往前开。这当然迟早会出问题，因为你根本不知道自己在干什么。</p>
<p>catch异常的时候，你不应该使用Exception这么宽泛的类型。你应该正好catch可能发生的那种异常A。使用宽泛的异常类型有很大的问题，因为它会不经意的catch住另外的异常（比如B）。你的代码逻辑是基于判断A是否出现，可你却catch所有的异常（Exception类），所以当其它的异常B出现的时候，你的代码就会出现莫名其妙的问题，因为你以为A出现了，而其实它没有。这种bug，有时候甚至使用debugger都难以发现。</p>
<p>如果你在自己函数的类型加上throws Exception，那么你就不可避免的需要在调用它的地方处理这个异常，如果调用它的函数也写着throws Exception，这毛病就传得更远。我的经验是，尽量在异常出现的当时就作出处理。否则如果你把它返回给你的调用者，它也许根本不知道该怎么办了。</p>
<p>另外，try { … } catch里面，应该包含尽量少的代码。比如，如果foo和bar都可能产生异常A，你的代码应该尽可能写成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo();</span><br><span class="line">&#125; <span class="keyword">catch</span> (A e) &#123;...&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (A e) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>而不是<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  foo();</span><br><span class="line">  bar();</span><br><span class="line">&#125; <span class="keyword">catch</span> (A e) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>第一种写法能明确的分辨是哪一个函数出了问题，而第二种写法全都混在一起。明确的分辨是哪一个函数出了问题，有很多的好处。比如，如果你的catch代码里面包含log，它可以提供给你更加精确的错误信息，这样会大大地加速你的调试过程。</p>
<h2 id="正确处理null指针">正确处理null指针</h2><p>穷举的思想是如此的有用，依据这个原理，我们可以推出一些基本原则，它们可以让你无懈可击的处理null指针。</p>
<p>首先你应该知道，许多语言（C，C++，Java，C#，……）的类型系统对于null的处理，其实是完全错误的。这个错误源自于Tony Hoare最早的设计，Hoare把这个错误称为自己的“billion dollar mistake”，因为由于它所产生的财产和人力损失，远远超过十亿美元！</p>
<p>这些语言的类型系统允许null出现在任何对象（指针）类型可以出现的地方，然而null其实根本不是一个合法的对象。它不是一个String，不是一个Integer，也不是一个自定义的类。null的类型本来应该是NULL，也就是null自己。根据这个基本观点，我们推导出以下原则：</p>
<p>尽量不要产生null指针。尽量不要用null来初始化变量，函数尽量不要返回null。如果你的函数要返回“没有”，“出错了”之类的结果，尽量使用Java的异常机制。虽然写法上有点别扭，然而Java的异常，和函数的返回值合并在一起，基本上可以当成union类型来用。比如，如果你有一个函数find，可以帮你找到一个String，也有可能什么也找不到，你可以这样写：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">String</span> find() throws NotFoundException &#123;</span><br><span class="line">  <span class="keyword">if</span> (...) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"found"</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NotFoundException();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>Java的类型系统会强制你catch这个NotFoundException，所以你不可能像漏掉检查null一样，漏掉这种情况。Java的异常也是一个比较容易滥用的东西，不过我已经在上一节告诉你如何正确的使用异常。</p>
<p>不要把null放进“容器数据结构”里面。所谓容器（collection），是指一些对象以某种方式集合在一起，所以null不应该被放进Array，List，Set等结构，不应该出现在Map的key或者value里面。把null放进容器里面，是一些莫名其妙错误的来源。因为对象在容器里的位置一般是动态决定的，所以一旦null从某个入口跑进去了，你就很难再搞明白它去了哪里，你就得被迫在所有从这个容器里取值的位置检查null。你也很难知道到底是谁把它放进去的，代码多了就导致调试极其困难。</p>
<p>解决方案是：如果你真要表示“没有”，那你就干脆不要把它放进去（Array，List，Set没有元素，Map根本没那个entry），或者你可以指定一个特殊的，真正合法的对象，用来表示“没有”。</p>
<p>需要指出的是，类对象并不属于容器。所以null在必要的时候，可以作为对象成员的值，表示它不存在。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">  <span class="built_in">String</span> name = <span class="literal">null</span>;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>之所以可以这样，是因为null只可能在A对象的name成员里出现，你不用怀疑其它的成员因此成为null。所以你每次访问name成员时，检查它是否是null就可以了，不需要对其他成员也做同样的检查。</p>
<p>函数调用者：明确理解null所表示的意义，尽早检查和处理null返回值，减少它的传播。null很讨厌的一个地方，在于它在不同的地方可能表示不同的意义。有时候它表示“没有”，“没找到”，有时候它表示“出错了”，“失败了”…… 你必须理解每一个null的意义，不能给混淆起来。</p>
<p>如果你调用的函数有可能返回null，那么你应该在第一时间对null做出“有意义”的处理。比如，上述的函数find，返回null表示“没找到”，那么调用find的代码就应该在它返回的第一时间，检查返回值是否是null，并且对“没找到”这种情况，作出有意义的处理。</p>
<p>“有意义”是什么意思呢？我的意思是，使用这函数的人，应该明确的知道在拿到null的情况下该怎么做，承担起责任来。他不应该只是“向上级汇报”，把责任踢给自己的调用者。如果你违反了这一点，就有可能采用一种不负责任，危险的写法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="built_in">String</span> foo() &#123;</span><br><span class="line">  <span class="built_in">String</span> found = find();</span><br><span class="line">  <span class="keyword">if</span> (found == <span class="literal">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当看到find()返回了null，foo自己也返回null。这样null就从一个地方，游走到了另一个地方。如果你不假思索就写出这样的代码，最后的结果就是代码里面随时随地都可能出现null。到后来为了保护自己，你的每个函数都会写成这样：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public <span class="keyword">void</span> foo(A a, B b, C c) &#123;</span><br><span class="line">  <span class="keyword">if</span> (a == <span class="literal">null</span>) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span> (b == <span class="literal">null</span>) &#123; ... &#125;</span><br><span class="line">  <span class="keyword">if</span> (c == <span class="literal">null</span>) &#123; ... &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>函数作者：明确声明不接受null参数，当参数是null时立即崩溃。不要试图对null进行“容错”，不要让程序继续往下执行。如果调用者使用了null作为参数，那么调用者（而不是函数作者）应该对程序的崩溃负全责。上面的例子之所以成为问题，就在于人们对于null的“容忍态度”。</p>
<p>上面这种“保护式”的写法，试图“容错”，试图“优雅的处理null”，其结果是让调用者更加肆无忌惮的传递null给你的函数。到后来，你的代码里出现一堆堆nonsense的情况，null可以在任何地方出现，都不知道到底是哪里产生出来的。谁也不知道出现了null是什么意思，该做什么，所有人都把null踢给其他人。最后这null像瘟疫一样蔓延开来，到处都是，成为一场噩梦。</p>
<p>正确的做法，其实是强硬的态度。你要告诉函数的使用者，我的参数全都不能是null，如果你给我null，程序崩溃了该你自己负责！至于调用者代码里有null怎么办，他自己该知道怎么处理（参考以上几条），不应该由函数作者来操心。</p>
<p>使用@NotNull和@Nullable标记。IntelliJ提供了@NotNull和@Nullable两种标记，加在类型前面，这样可以比较可靠地防止null指针的出现。IntelliJ本身会对含有这种标记的代码进行静态分析，指出运行时可能出现NullPointerException的地方。在运行时，会在null指针不该出现的地方产生IllegalArgumentException，即使那个null指针你从来没有deference。这样你可以在尽量早期发现并且防止null指针的出现。</p>
<p>扩展话题：关于Optional类型和Union类型</p>
<p>有些语言，比如Java 8和Swift，提供了一种叫“Optional类型”的东西。比如在Java 8里面，你可以使用Optional来表示“可能是String，可能没有”。很多人以为有了Optional类型，就可以完美的解决null指针的问题，然而它并不是想象的那样完美。</p>
<p>因为你看到的类型是Optional，而不是String，所以类型系统不允许你直接把它当String来用。这多出来的一层关卡，可以防止你不问三七二一就取它的值，你总要想一下。然而这并不能从根本上解决问题。Optional并不能完全阻止你产生跟NullPointerException等价的运行时错误。因为你仍然可以写这样的代码：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Optional&lt;<span class="built_in">String</span>&gt; x = Optional.empty();</span><br><span class="line"><span class="built_in">String</span> y = x.get();</span><br></pre></td></tr></table></figure></p>
<p>没有检查x.isPresent()就使用x.get()，结果出现NoSuchElementException。这其实等价于没有检查null就在dereference它。只不过现在出现的不是NullPointerException，而是NoSuchElementException。两个都是运行时错误，换汤不换药，程序照样崩溃。所以你看到了，Optional只是一种善意的“提示”，它使你不会在完全不知情的情况下犯错误。可是如果你忽略这种提示，照样可以犯一样的错误。Optional并没有任何强制性的力量。</p>
<p>Swift的Optional类型跟Java的是一样的问题，Swift的手册里指出：“Using the ! operator to unwrap an optional that has a value of nil results in a runtime error.” 所以，Swift并不能静态地阻止你对一个值为nil的Optional进行!操作。如果你做了，就会产生“运行时错误”。</p>
<p>另外，Optional类型会导致程序变得复杂。Optional和null指针，在结构上有一个很大的差别。Optional比null指针多了一层数据结构。Optional把需要的值放在了另外一个对象里面。你必须用x.get()来得到里面这个值，这跟使用null的时候很不一样。当你判断了一个String不可能是null，你不需要再做一次get把内容给取出来。比如：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span> found = find();</span><br><span class="line"><span class="keyword">if</span> (found != <span class="literal">null</span>) &#123;</span><br><span class="line">  total += found.length();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>判断found不是null之后，我们可以直接用found.length()得到它的长度，而不需要先使用found.get()。这个例子貌似小事，然而如果Optional类型被放进另外的结构或者容器里面，或者包含了另外类型，你就知道它的繁琐和痛苦了。Optional的这个问题，跟Haskell的Maybe类型的问题一样，经常导致类型嵌套层数太多，太烦。</p>
<p>相比之下，union类型系统可以完全静态地防止NullPointerException，而不导致类型的过度嵌套。Union类型可以完全的涵盖Optional类型的功能，非常的简单，而且有很多其它的好处。这种类型系统已经存在于Typed Racket语言（一个Scheme的后代），还没有面世的Yin语言也实现了union类型。PySonar的类型推导系统里面也具有union类型。Union类型系统非常强大，它不但可以完全静态地消灭NullPointerException，而且可以取代Java等语言的exception机制。它让错误处理变得非常严密，却又非常方便。</p>
<p>不过需要注意的是，就算你有了union类型系统，完全静态地防止了NullPointerException，上面提到的几条对待null的原则仍然是有用的。在有union类型的语言里面，一个容易犯的错误是不假思索的扩展union类型，把什么可能性都加进去，结果最后得到很大的union类型。这导致很多变量和参数具有union类型，每个变量都有可能是好多种东西，以至于你需要做好几个判断才能通过类型检查。这种现象跟null指针的泛滥的问题并没有本质的区别，因为你没能有效地控制住“可能性”。这个“可能性爆炸”的问题，程序语言也许不能给你很好的帮助。只有靠自己，遵循上面的原则，尽早排除union类型或者减少其中的可能性，你才能避免这种混乱。</p>
<h2 id="防止过度工程">防止过度工程</h2><p>人的脑子真是奇妙的东西。虽然大家都知道过度工程（over-engineering）不好，在实际的工程中却经常不由自主的出现过度工程。我自己也犯过好多次这种错误，所以觉得有必要分析一下，过度工程出现的信号和兆头，这样可以在初期的时候就及时发现并且避免。</p>
<p>过度工程即将出现的一个重要信号，就是当你过度的思考“将来”，考虑一些还没有发生的事情，还没有出现的需求。比如，“如果我们将来有了上百万行代码，有了几千号人，这样的工具就支持不了了”，“将来我可能需要这个功能，所以我现在就把代码写来放在那里”，“将来很多人要扩充这片代码，所以现在我们就让它变得可重用”……</p>
<p>这就是为什么很多软件项目如此复杂。实际上没做多少事情，却为了所谓的“将来”，加入了很多不必要的复杂性。眼前的问题还没解决呢，就被“将来”给拖垮了。人们都不喜欢目光短浅的人，然而在现实的工程中，有时候你就是得看近一点，把手头的问题先搞定了，再谈以后扩展的问题。</p>
<p>另外一种过度工程的来源，是过度的关心“代码重用”。很多人“可用”的代码还没写出来呢，就在关心“重用”。为了让代码可以重用，最后被自己搞出来的各种框架捆住手脚，最后连可用的代码就没写好。如果可用的代码都写不好，又何谈重用呢？很多一开头就考虑太多重用的工程，到后来被人完全抛弃，没人用了，因为别人发现这些代码太难懂了，自己从头开始写一个，反而省好多事。</p>
<p>过度地关心“测试”，也会引起过度工程。有些人为了测试，把本来很简单的代码改成“方便测试”的形式，结果引入很多复杂性，以至于本来一下就能写对的代码，最后复杂不堪，出现很多bug。</p>
<p>世界上有两种“没有bug”的代码。一种是“没有明显的bug的代码”，另一种是“明显没有bug的代码”。第一种情况，由于代码复杂不堪，加上很多测试，各种coverage，貌似测试都通过了，所以就认为代码是正确的。第二种情况，由于代码简单直接，就算没写很多测试，你一眼看去就知道它不可能有bug。你喜欢哪一种“没有bug”的代码呢？</p>
<p>根据这些，我总结出来的防止过度工程的原则如下：</p>
<blockquote>
<ul>
<li>先把眼前的问题解决掉，解决好，再考虑将来的扩展问题。</li>
<li>先写出可用的代码，反复推敲，再考虑是否需要重用的问题。</li>
<li>先写出可用，简单，明显没有bug的代码，再考虑测试的问题</li>
</ul>
</blockquote>
]]></content>
    <summary type="html">
    <![CDATA[<p>文章转自: <a href="http://www.yinwang.org/blog-cn/2015/11/21/programming-philosophy/">yinwang</a><br>编程是创造性的工作，是一门艺术。精通任何一门艺术，都需要很多的练习和领悟，所以这里提出的“智慧”，并不是号称一天瘦十斤的减肥药，它并不能代替你自己的勤奋。然而我希望它能给迷惑中的人们指出一些正确的方向，让他们少走一些弯路，基本做到一分耕耘一分收获。</p>]]>
    
    </summary>
    
      <category term="思考" scheme="http://strucoder.com/tags/%E6%80%9D%E8%80%83/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对做学问一些个人浅薄的感慨]]></title>
    <link href="http://strucoder.com/2015/11/21/%E5%AF%B9%E5%81%9A%E5%AD%A6%E9%97%AE%E4%B8%80%E4%BA%9B%E4%B8%AA%E4%BA%BA%E6%B5%85%E8%96%84%E7%9A%84%E6%84%9F%E6%85%A8/"/>
    <id>http://strucoder.com/2015/11/21/对做学问一些个人浅薄的感慨/</id>
    <published>2015-11-21T00:58:59.000Z</published>
    <updated>2015-11-21T04:23:08.000Z</updated>
    <content type="html"><![CDATA[<p>无意间在阮一峰的Twitter上发现了他的书籍<code>如何做一个有思想的人</code>, 顺着他提供的链接，我看到了他在2013年9月写过的一篇文章<a href="http://www.ruanyifeng.com/blog/2013/09/liang_shuming.html" target="_blank" rel="external">梁漱溟：做学问的八个境界</a><br>看了他这篇文章，让我认识到一个人有真正属于自己的思想是多么的重要！以及认识那些有思想以及有属于自己学问的人时多么的重要。<br><a id="more"></a></p>
<h2 id="个人的一些理解">个人的一些理解</h2><p>我也摘录了一些他文章里面的一些我觉得很不错的句子，当然，好的句子有很多，有些也可能是我目前这个阶段暂时还弄不明白的.<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/veWHujzSB9T6KYp" alt="好句子"></p>
<h3 id="关于读书">关于读书</h3><p>其实现在想想自己目前就读书这件事的一些不足，一方面是自己目前读得书籍的知识范围有些局限，因为我读的书大部分是关于技术的，这个情况是我入大学以及毕业以来的<br>情况，我在初中也读过一些自传，不过也不多，也就两本,一本是《戴笠传》，一本是《张灵甫传》，说实话，读完后，那些里面的文字所描述的画面以及透过文字我可以感受到<br>当是那些人的想法，也许这个想法也是我自己的想法，这也就是阮一峰在文里提到的，将书中的知识吸取为己有，不去旁征引博，自己能不借助各种辞藻能说出自己的所以然<br>做到这样才是真正的读书。 目前断断续续读的是《杜月笙传》。工作后的一段时间，我也曾为了学习新的知识，而花大量时间读书。而现在，可能是由于自己的技术上确实<br>上升了一个层次而变的有些眼高手低，但是我也意识到了这样的问题，我也在努力去改。之所以出现这样，也是自己所学知识的不足以及自己眼光被局限了。这里的知识也可<br>指阮一峰文章的学问。</p>
<h3 id="关于用心">关于用心</h3><p>我理解的用心一个最明显的特征就是是否态度端正。用心做好一件事说困难也困难说简单也简单。用心需要一个人的执行力，毅力以及时间。每个人的一生当中一定有用心的时候<br>以及不用心的时候，而这个比例是怎么样也决定了这个人这一生的样子. 我这里不叙述我是否用心。因为说没意思.</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>无意间在阮一峰的Twitter上发现了他的书籍<code>如何做一个有思想的人</code>, 顺着他提供的链接，我看到了他在2013年9月写过的一篇文章<a href="http://www.ruanyifeng.com/blog/2013/09/liang_shuming.html">梁漱溟：做学问的八个境界</a><br>看了他这篇文章，让我认识到一个人有真正属于自己的思想是多么的重要！以及认识那些有思想以及有属于自己学问的人时多么的重要。<br>]]>
    
    </summary>
    
      <category term="思想" scheme="http://strucoder.com/tags/%E6%80%9D%E6%83%B3/"/>
    
      <category term="杂谈" scheme="http://strucoder.com/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[wkhtmltopdf在ubuntu中中文设置]]></title>
    <link href="http://strucoder.com/2015/11/19/wkhtmltopdf%E5%9C%A8ubuntu%E4%B8%AD%E4%B8%AD%E6%96%87%E8%AE%BE%E7%BD%AE/"/>
    <id>http://strucoder.com/2015/11/19/wkhtmltopdf在ubuntu中中文设置/</id>
    <published>2015-11-19T09:07:26.000Z</published>
    <updated>2015-11-19T09:26:34.000Z</updated>
    <content type="html"><![CDATA[<p>前两天利用闲暇时间折腾出了一个可以将文档转换成PDF或者PNG的web工具，用的第三方工具就是<code>tower</code>开源的<a href="https://github.com/mycolorway/simditor" target="_blank" rel="external">编辑器</a>, 以及<br><a href="http://wkhtmltopdf.org" target="_blank" rel="external">wkhtmltopdf</a>. 加上我自己对编辑器的扩展功能以及修正了在Ubuntu上中文文字显示问题。<br><a id="more"></a></p>
<h2 id="安装相关的工具">安装相关的工具</h2><p>安装编辑器很简单，就是去<a href="https://github.com/mycolorway/simditor/releases" target="_blank" rel="external">Github</a>下载相关的代码之后按照，其说明文档操作，这里不再叙述。<br>安装<a href="http://wkhtmltopdf.org/downloads.html" target="_blank" rel="external">wkhtmltopdf</a>之后选着相关的平台。</p>
<h2 id="使用过程遇到的问题">使用过程遇到的问题</h2><p>在我使用的使用，因为自己开发的时候用的是<code>Mac</code> 所以英文和中文都可以正常显示，但是当我部署到我的<code>vps</code>上的时候我发现，一开始我的中文出现了乱码。修复一下后<br>出现没有显示中文。这个两个问题.</p>
<h2 id="解决办法">解决办法</h2><h3 id="解决中文乱码的问题">解决中文乱码的问题</h3><p>这个很好解决, 就是在你的生成模板中添加<code>meta</code>标签:<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">meta</span> <span class="attribute">http-equiv</span>=<span class="value">"content-type"</span> <span class="attribute">content</span>=<span class="value">"text/html;charset=utf-8"</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<h3 id="解决不显示中文">解决不显示中文</h3><p>解决这个问题我花了半个小时，确实让我折腾了一下。<br>具体的办法以及步骤</p>
<ol>
<li>在命令控制台运行<code>locale-gen zh_CN.UTF-8</code></li>
<li>之后将zh_CN:zh 追加到 /etc/default/locale 中得LANGUAGE上<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/xs0LIMp3ah8IzkNC" alt="locale"></li>
<li>之后去<a href="https://help.ubuntu.com/community/Fonts#Chinese.2C_Japanese.2C_and_Korean_Fonts" target="_blank" rel="external">这个网站</a>下载相应的字体</li>
<li>我下载的是<a href="https://launchpad.net/ubuntu/+source/ttf-wqy-microhei/0.2.0-beta-1ubuntu1" target="_blank" rel="external">这个字体</a></li>
<li>解压，将*.ttf文件拷贝到自己的<code>home</code>目录下得<code>.fonts</code>下，如果没有就创建</li>
<li>刷新字体缓存: <code>sudo fc-cache -f -v</code></li>
</ol>
<h3 id="最后">最后</h3><p>我的项目开源了，在<a href="https://github.com/struCoder/pngOrPdfHtml" target="_blank" rel="external">这里</a>.<br>具体的访问地址: <a href="http://doc.strucoder.com" target="_blank" rel="external">http://doc.strucoder.com</a><br>由于服务器在国外有些时候网络有些卡。</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前两天利用闲暇时间折腾出了一个可以将文档转换成PDF或者PNG的web工具，用的第三方工具就是<code>tower</code>开源的<a href="https://github.com/mycolorway/simditor">编辑器</a>, 以及<br><a href="http://wkhtmltopdf.org">wkhtmltopdf</a>. 加上我自己对编辑器的扩展功能以及修正了在Ubuntu上中文文字显示问题。<br>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://strucoder.com/tags/javascript/"/>
    
      <category term="ubuntu" scheme="http://strucoder.com/tags/ubuntu/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[我眼中的互联网圈]]></title>
    <link href="http://strucoder.com/2015/11/17/%E6%88%91%E7%9C%BC%E4%B8%AD%E7%9A%84%E4%BA%92%E8%81%94%E7%BD%91%E5%9C%88/"/>
    <id>http://strucoder.com/2015/11/17/我眼中的互联网圈/</id>
    <published>2015-11-17T01:08:35.000Z</published>
    <updated>2015-11-17T02:23:21.000Z</updated>
    <content type="html"><![CDATA[<p>我个人是2014年6月中旬开始我人生当中第一份实习工作，这样也算是步入了这个所谓的互联网创业圈吧。从那时开始到现在已经有一年半了，就从这一年半的时间<br>里我来说说我对目前这个创业圈的认识。</p>
<a id="more"></a>
<h2 id="各种各样的创业项目以及创业人">各种各样的创业项目以及创业人</h2><p>我见过很多创业人也听过很多的创业者，这也得力于我跟随着<a href="http://shimo.im" target="_blank" rel="external">石墨</a>创业团队进驻36kr的kr空间有关，在这其间我听过很多的所谓的<br>创业故事，以及各种规划书之类的。当时我由于经历少，感觉这些人都是大咖，他们的团队都是很牛x，他们的规划真是好，他们的团队都是精英。等等，反正<br>都是积极的向上的看法，因为，所有的那些创业团队的所谓的CEO都是很有故事很有学历的人。你完全没有任何质疑的理由，就算有人质疑，也会很快被那些<br>所谓的正能量携带者所带好。可能你读到这会认为这篇文章是我带着消极的负能量所写。其实不然，我现在是站在客观的角度去评价如今的互联网创业圈。因为<br>我没有理由带着负能量去写。就这样，我经历的互联网创业的高潮时期吧。这个时候融资确实很容易，也许是那些创业者的创业想法确实是挺好。</p>
<h3 id="现在我们看看那些创业者">现在我们看看那些创业者</h3><p>也就是一个初创公司的CEO，客观的说，一个公司的CEO不需要太高的智商，但是一定要有很高的情商，如果没有很高的情商，但是智商特别高，<br>如果此时我作为投资人，我一定会关心他得合伙人，因为智商太高的人作为CEO注定不会有多大的成功，这些人往往需要一个人去引导去处理其身边各种来自<br>用户来自各种媒体的问题。纵观海内外的互联网公司的巨头的CEO，大部分是技术出生。也是世界级的名牌大学毕业，但是他们都不是一个人都是有几个人一起<br>创业。他们中有智商特高也有情商特高的人。也有极少的时智商和情商都非常高的人。总之这些成功者都是一队人。而如今的互联网创业，更加的需要一个明智<br>的CEO，因为现在的创业形势更加的激烈，机遇稍纵即逝。举个例子，嘀嘀打车的创始人程唯。我觉得他是一个情商非常高的人，理所当然的他得胸怀也是特别广<br>作为嘀嘀打车的创始人都可以让别人也就是柳青作为嘀嘀打车的总裁。这样一个决定需要超前的洞察力以及更加重要的胸怀包容。也就是这样一个人在他的公司<br>基因上决定了这是一个很了不起的公司。反观现在的绝大部分的创业者，都是这样一个头衔: 创始人兼CEO, 当然这样的称呼无可厚非。但是，为了自己创业公司<br>在A轮融了以后，作为创始人应当必须反省自己，以后公司团队越来越大自己是否能够能正确的决策以及管理好更多的人。这是一个非常重要的问题。如果那时<br>还看不透。注定B轮死或者C轮死或者Z轮死。</p>
<h3 id="那些创业项目">那些创业项目</h3><p>创业项目的好坏直接影响到了创业公司以后的发展。我自己也发现很多创业者，都是脑洞打开，他们不是依据当今社会需要什么项目，而是根据自己的猜想以及<br>不切实际的联想最终脑袋一热说，这个绝壁能成功。事实往往如此。这样的创业项目99.999%会死。剩下的0.001%也许会成功，因为可能这个创业者洞察力<br>很高，真的被他想到了。这样的事也没有什么不可能。我见过很多的创业项目。99%都是加上了所谓的o2o，不知道是什么原因。现在的创业者都是要加上这<br>三个字符来显得自己高大上。或许这也是这个时代的浮躁吧。马云的o2o是立足那个时代背景。你的o2o是基于什么？你的想法？还是社会的需要？历史不可能重复<br>成功的秘诀也不会相同。</p>
<h2 id="创业者的说与做">创业者的说与做</h2><p>当前要说创业公司的创始人，在我所见的里面。大部分都是非常的能说的。各种和投资对谈各种在自媒体上露脸。很少的时间是参与自己团队的工作，即使是<br>参与也是以创始人的身份参与，为什么这样说，因为，他们可以毫无理由的让你习惯他们的想法。我们回头看看历史，很多成功者都是非常低调的。难道当前<br>的互联网非要以这样的形式才能让自己的团队发展的更好? 所谓的创业规划说只是说给自己以及投资人听的。用户看不到，作为创业者你要知道你所做的都不是为<br>了你自己，是为了你的团队你的用户以及一个互联网圈子。在这里我对那些只为了发家致富的创业者不说什么，因为毫无意义，他们根本谈不上创业，顶多<br>就是想一夜爆发的土包子。</p>
<h2 id="创业领域">创业领域</h2><p>总得来说有教育，医疗，社交，办公，商城等等。我个人最不看好的就是<strong>医疗</strong>和<strong>社交</strong>。先说为什么看不好医疗。原因很简单，所有关注医疗的人90%<br>是50或者60以上的老龄人，他们对互联网的认识非常的少而更大的需求用户是农村领域的老年人。他们就更加的不懂什么是互联网了。可以说，医疗领域的互联网<br>发展的偏早。其次，当下互联网最关心的是活跃次数，很简单的事，哪一个正常的人没事天天和医生交流啊，天天看医疗相关的什么忌讳。还有就是医生也不会<br>有很多时间聊天。正常人都不会这样做所以我很不看好医疗。第二个不看好的是社交。理由很简单，未来式的社交，当下你又做不到。现在技术的社交。<br>你已经没有什么发展机会，因为几乎被垄断</p>
<h2 id="个人期望">个人期望</h2><ul>
<li>互联网圈能进行大浪淘沙，并不是洗牌。是淘沙，淘汰的淘。过滤些没什么意思已经对社会发展历程没什么作用的公司团队，尽早死。为什么？这样可以将<br>社会资本投入到适合社会发展的项目上，因为社会总资本是固定的。</li>
<li>对人才的要求更加的严格。社会的进步需要学习，让那些不学习的人回到他们该去的地方</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>我个人是2014年6月中旬开始我人生当中第一份实习工作，这样也算是步入了这个所谓的互联网创业圈吧。从那时开始到现在已经有一年半了，就从这一年半的时间<br>里我来说说我对目前这个创业圈的认识。</p>]]>
    
    </summary>
    
      <category term="创业" scheme="http://strucoder.com/tags/%E5%88%9B%E4%B8%9A/"/>
    
      <category term="见解" scheme="http://strucoder.com/tags/%E8%A7%81%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人迹罕至的秋天]]></title>
    <link href="http://strucoder.com/2015/11/01/%E4%BA%BA%E8%BF%B9%E7%BD%95%E8%87%B3%E7%9A%84%E7%A7%8B%E5%A4%A9/"/>
    <id>http://strucoder.com/2015/11/01/人迹罕至的秋天/</id>
    <published>2015-11-01T13:33:39.000Z</published>
    <updated>2015-11-01T14:47:46.000Z</updated>
    <content type="html"></content>
    <summary type="html">
    
    </summary>
    
      <category term="北京" scheme="http://strucoder.com/tags/%E5%8C%97%E4%BA%AC/"/>
    
      <category term="生活" scheme="http://strucoder.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
      <category term="秋天" scheme="http://strucoder.com/tags/%E7%A7%8B%E5%A4%A9/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让阳光洒在身上]]></title>
    <link href="http://strucoder.com/2015/10/31/%E8%AE%A9%E9%98%B3%E5%85%89%E6%B4%92%E5%9C%A8%E8%BA%AB%E4%B8%8A/"/>
    <id>http://strucoder.com/2015/10/31/让阳光洒在身上/</id>
    <published>2015-10-31T13:56:26.000Z</published>
    <updated>2015-10-31T14:54:36.000Z</updated>
    <content type="html"><![CDATA[<p>今天是礼拜六，上午我一直睡到12点，起床后收拾一下，就骑着我的单车到海淀桥那边的麦当劳吃午饭，也应该是有些饿，点了一个板烧鸡腿堡套餐外加一个脆骨鸡腿。<br>可能是人多的原因，我在室内已经脱掉了外套。漫不经心的吃着。<br><a id="more"></a></p>
<p>吃完后去了一趟海淀新华书店，我发现新华书店里的人真的是太多了，完全和我老家县城的新华书店不一样，这里的不一样不是指的装饰或者布局，而是按每平米有多少人<br>进行对比的。封闭的空间让室内温暖了许多，同时也让人感到昏昏欲睡。漫不经心的看了一些书后，骑着我的单车往住的地方。在由东向西的方向骑到海淀公园的外围时我停下了<br>自行车，自己推着单车漫不经心的走。</p>
<p><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/yangguang2.JPG?imageMogr2/rotate/90" alt="阳光洒在身上_0"><br>走着走着我解开了衣服，我要让洒在我外表上的阳光刺透我的身体，我要让我的内心感到太阳的温暖。路旁停着很多的出租车，车里的司机也在懒散的睡着午觉。阳光<br>透过车的挡风玻璃照在似乎已经睡着的司机身上。一切都是那么的和谐安详。此刻我感到这个世界是多么的美好，我尽量的放空自己，让自己闭上眼睛享受这恰到好处的阳光。<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/yangguang.JPG?imageMogr2/rotate/90" alt="阳光洒在身上_1"></p>
<p>北京的秋天，是萧瑟的。但也是温暖的，只不过这个温暖是那么的短暂，因为短暂所以珍贵。</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天是礼拜六，上午我一直睡到12点，起床后收拾一下，就骑着我的单车到海淀桥那边的麦当劳吃午饭，也应该是有些饿，点了一个板烧鸡腿堡套餐外加一个脆骨鸡腿。<br>可能是人多的原因，我在室内已经脱掉了外套。漫不经心的吃着。<br>]]>
    
    </summary>
    
      <category term="生活" scheme="http://strucoder.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[js经典题目的考试]]></title>
    <link href="http://strucoder.com/2015/10/29/js%E7%BB%8F%E5%85%B8%E9%A2%98%E7%9B%AE%E7%9A%84%E8%80%83%E8%AF%95/"/>
    <id>http://strucoder.com/2015/10/29/js经典题目的考试/</id>
    <published>2015-10-29T10:28:37.000Z</published>
    <updated>2015-10-29T10:34:04.000Z</updated>
    <content type="html"><![CDATA[<p>一个朋友在群里发了一条javascript测试链接。<a href="http://javascript-puzzlers.herokuapp.com" target="_blank" rel="external">点击</a></p>
<p>我去做了之后连一半的分都没有拿到。。。我已经哭晕在厕所。。。<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/QQ20151029-7.png" alt="测试结果"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>一个朋友在群里发了一条javascript测试链接。<a href="http://javascript-puzzlers.herokuapp.com" target="_blank" rel="external">点击</a></p>
<p>我去做了之后连一半的分都没有拿]]>
    </summary>
    
      <category term="javascript" scheme="http://strucoder.com/tags/javascript/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[人生第一次碰到拖欠工资]]></title>
    <link href="http://strucoder.com/2015/10/23/%E4%BA%BA%E7%94%9F%E7%AC%AC%E4%B8%80%E6%AC%A1%E7%A2%B0%E5%88%B0%E6%8B%96%E6%AC%A0%E5%B7%A5%E8%B5%84/"/>
    <id>http://strucoder.com/2015/10/23/人生第一次碰到拖欠工资/</id>
    <published>2015-10-23T13:39:53.000Z</published>
    <updated>2015-10-23T14:07:43.000Z</updated>
    <content type="html"><![CDATA[<p>自从我步入这个互联网行业开始我从未想过我居然也会遇到自己所服务的公司拖欠工资，拖欠的薪资是一回事，但是对我的影响又是另外一回事了.</p>
<a id="more"></a>
<p>我不是那种背后说人坏话的人，我这个人有什么话会直接当着这个人的面直接说，所以我在这我不会透露相关的公司以及相关的人. 我在这片文章里只是<br>做一些个人的感悟以及个人对国家宪法赋予的权力的认识.</p>
<h2 id="事情的大概经过">事情的大概经过</h2><p>时间，也就是这几天，主要发生在今天，因为上家公司发工资本来就会拖延，给我的<code>offer</code>上写的是每月的15，可实际是往后拖延了5天左右. 按照纪录，我是上个月<br>的20号左右正式离职，也就是2015年9月20号, 其实也不算离职，因为那家公司没有和我签订合同，所以也就没有社保之类的福利，但是但是单纯的我还是选着了加入.<br>我个人其实不在乎这些福利，如果我在乎我就不会去了。其它一些员工也有的已经转正了，但是也是没有签合同，签合同的只有两三个。<br>我在这家公司呆了两个多月。其实按照，劳动法所规定的，这家公司这样做就是违法的. 这个暂且不说。在我离职后将近一个月，也就是这几天，按照上家公司的<br>流程，应该发工资，直到今天下午的五点多，我通过QQ联系我上家公司的同事A，A说工资已经下午4点就发了，当时我的第一感觉就是，会不会财务发工资发漏了。我就<br>通过QQ问到公司在北京的直接leader，没想到，他居然说我没有按照<code>标准</code>流程走离职手续, 薪资发不发不知道，虽然他嘴上说，这不是钱的事，其实就是钱的事，就好像你<br>问到一个人，问他过的好不好，如果这个人一直在说，过得好，过的幸福，其实这个人就是过得不幸福。同样，这件事也是如此. 我当时就知道这个不靠谱以及人品上有些问题的leader心里的<br>想法。 而且他还强调几遍，这不是钱的问题，我有截图，我这里就不贴了。前面说了，我不是背后捅人刀子的人，我敢当面说！</p>
<h2 id="我内心的感触">我内心的感触</h2><p>第一个感觉就是对这个leader的寒心，说我不在乎那20天的薪资是假的，因为最近开销很大，生活上却是有些拮据. 但是钱可以借，可这人在我心里的形象已经彻底毁了<br>我不知道其他人对他什么看法，但是在我的感受里，我觉得，这样的人，就是人品上的问题，在我眼里凡是上升到人品的问题，就已经很严重了。我也不想再多说什么，钱我可以<br>不要，但是我还是得执行中华人民共和国宪法所赋予的公民正当的权力。这个权力在接下来一段时间里我回始终的贯彻下去.</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>自从我步入这个互联网行业开始我从未想过我居然也会遇到自己所服务的公司拖欠工资，拖欠的薪资是一回事，但是对我的影响又是另外一回事了.</p>]]>
    
    </summary>
    
      <category term="工作" scheme="http://strucoder.com/tags/%E5%B7%A5%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在大学边上班-吃大学食堂]]></title>
    <link href="http://strucoder.com/2015/10/21/%E9%98%B6%E6%AE%B5%E6%80%A7%E7%94%9F%E6%B4%BB%E6%84%9F%E8%A7%A6/"/>
    <id>http://strucoder.com/2015/10/21/阶段性生活感触/</id>
    <published>2015-10-21T04:19:11.000Z</published>
    <updated>2015-10-21T14:36:12.000Z</updated>
    <content type="html"><![CDATA[<p>为什么今天写这个，一个月前我来到了紧邻北京交通大学的知行大厦这边的公司上班，所以平时中午和晚上都在其食堂吃饭，虽说就是简简单单的吃饭，但是有了那个学校<br>的气氛，就不得不有所感想了.</p>
<a id="more"></a>
<h2 id="我的短暂属于大学的生活">我的短暂属于大学的生活</h2><p>之所以称之为短暂，是因为我上的是大专，武汉的一所大专。<br>之所以称之为属于大学的生活，是因为我在本来就是三年制的大学生活里(其实我就有一年半多, 之后找院长签字出去实习了)，4/5的时间花在了学习上。<br>我在大学里从大一开始从未参加过各种社团，唯一的集体活动就是当时自己的思想还很纯真的认为想加入某党而加入的学校政研社，我想绝大多是大学也是如此。<br>我在大一的上学期，我还比较<code>老实</code>的天天去教室上课，后来，自己有了自己的做法以及想法，知道了如何根据自己的兴趣，去学习，我就不再去教室上课了，原因很简单</p>
<blockquote>
<ul>
<li>老师讲的我都会</li>
<li>我的兴趣不在课堂上老师所讲的内容</li>
<li>课堂上没有难倒我的难题</li>
</ul>
</blockquote>
<h2 id="学习,学生到实习生">学习,学生到实习生</h2><p>所以那个时候，我几乎一周只去一两次课堂，那么我在寝室干什么，说到这，我不得不佩服当时的自己，那时我对知识的渴望不知道为何那么的<code>饥渴</code>, 一段时间几乎每天<br>都是凌晨三点才睡觉，早上睡到十点，那时觉得晚上安静，适合自己的学习。同时我也始终认为自己的脑子笨，效率不高，所以我宁愿花多的时间来弥补这方面，有人会说<br>你可以先学习什么什么如何提高效率之类的知识，我想说，话谁都会说，何况当时自己只知道追求自己想要的知识，并没有关注如何提高效率的事。<br>就这样我一点一滴学习学校的<code>微软</code>路线。在我学习了一段时间后发现我该学的都学了，之后不知道怎么去接着往下学了，或者说当时有些迷茫了。一方面是自己学习知识<br>方向的不确定性以及学习的知识不知道如何应用, 另一方面是当时真的不知道如何走<code>微软</code>这条路线。迷茫了消沉一段时间后，2013年11月我注意到了<code>Meteorjs</code>,<br>这个让我执迷框架，当时国内关于<code>Meteorjs</code>的资料几乎是没有, 我每天就包着其官方文档以及自己的理解加上一本国外的英文书籍慢慢的学习了。<br>年后我对<code>Meteorjs</code>的了解有了很大的进展并且我自己写了一个类似于BBS的小网站部署在<code>Meteorjs</code>提供的官网上。紧接着，在我深入学习<code>Meteorjs</code>的时候<br>我遇见了<code>Nodejs</code>，也就是2014年年初的时候。遇见<code>Nodejs</code>再一次让我执狂, 因为一开始自己习惯了<code>ASP.NET</code>系列以及<code>C#</code>语言，当时对<code>javascript</code>这门语言又不是特别<br>的熟悉，所以就一下子扎进去学习. 当时也是这样的情况，国内几乎没有什么好书, 当时唯一一本好书就是&lt;深入浅出Node&gt;, 可这本书不适合入门者的学习，所以我又下载了其它<br>的一些英文书籍，毕竟国内技术的脚步始终比国外慢几拍. 之后就是学习。在2014年6月9日我来到了北京。10日我在我人生第一家公司做了实习生。</p>
<h2 id="时间的流逝,_对不起自己的大学生活">时间的流逝, 对不起自己的大学生活</h2><p>其实写着一段，我心里也不知道如何表述，因为，或许没有当初自己的努力，我不可能有今天能和很多高手以及高学历的人在一起工作以及不一样的职场经历,<br>如果自己不努力，平平凡凡的度过大学, 我不知道现在在那个二三线城市工作，或者回家回到那个小县城工作，住在乡下的房子。其实我想说，我们这一代，在没有<br>有钱的父母有权的父母的庇护下，在自己长到父母们认为该成家立业的年纪时自己的压力有多大，如果自己还有一颗上进心的话，我觉得还是有压力的，如果没有上进心，不求进取<br>只愿沿着父母的生活方式在乡下盖房娶妻添子生活。那也是一种生活方式，也没有什么错，但是只要自己努力，生活就可以过的更好，何尝不可呢？正是这种为了更好的生活以及对自己<br>下一代的负责，我在不断的前行着。人生总归不可能事事如愿，目前我只能说，自己没有一个像样的大学生活，对不起那段岁月。<br>但是，我现在至少证明了我有能过的更好的生活以及能再好的能力，同时，我不会让我的下一代的经历和我一样。 我要给他一个什么年龄段就应该过着什么样的生活。</p>
<p>这是我这一代人一小步进步，但是如果整个民族如此，那就是国家的一个大进步.</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>为什么今天写这个，一个月前我来到了紧邻北京交通大学的知行大厦这边的公司上班，所以平时中午和晚上都在其食堂吃饭，虽说就是简简单单的吃饭，但是有了那个学校<br>的气氛，就不得不有所感想了.</p>]]>
    
    </summary>
    
      <category term="生活" scheme="http://strucoder.com/tags/%E7%94%9F%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[nginx-反向代理之域名转发]]></title>
    <link href="http://strucoder.com/2015/10/19/nginx-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B9%8B%E5%9F%9F%E5%90%8D%E8%BD%AC%E5%8F%91/"/>
    <id>http://strucoder.com/2015/10/19/nginx-反向代理之域名转发/</id>
    <published>2015-10-19T05:01:45.000Z</published>
    <updated>2015-10-19T06:15:46.000Z</updated>
    <content type="html"><![CDATA[<p>前几天在我的个人托管在新加坡的VPS主机上上线了我的个人博客，因为我之前在这个VPS上上线过我之前的一个<a href="http://itodo.me" target="_blank" rel="external">项目</a>, 也是通过nginx进行转发的。<br>而现在又要同样在<code>80</code>转发到我程序运行的端口，所以就要通过nginx配置文件中的<code>server_name</code>进行相应的转发，但是我在这里翻了一个错误，如果我自己不犯这个小错误<br>我就不会来写这篇小文章了。</p>
<a id="more"></a>
<p>我的<code>itodo.me</code>的<code>nginx</code>配置文件一开始是这样的<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">  server_name: *.itodo.me;</span><br><span class="line">  ....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>因为只是一个转发的过程，所以我在配置我的个人博客的时候，我就拷贝了一份<code>itodo</code>的nginx配置文件，并且改一下<code>server_name</code>为<code>*.strucoder.com</code><br>同时呢，在<code>cloudFare</code>的域名解析中将<code>strucoder.com</code>的A记录指向我的VPS服务器的地址。而这一步的操作也开始和我的<code>itodo</code>是一样的。所以，今天我访问<br><code>http://itodo.me</code>的时候，居然直接解析到我的个人博客网站的程序里的，也就是出来的页面是我的个人博客的页面，我就知道问题出在<code>nginx</code>转发的时候。原因<br>很简单，因为，一开始我在配置<code>server_name</code>的时候，其配置为<code>*.domain.com</code>; 这样的只对二级域名有用, 所以我在访问这两个域名的二级域名的时候没有出问题的<br>原因。所以到这，知道了原因，那么解决办法就出来了，就是分开写。<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">server_name: itodo.me www.itodo.me;</span><br></pre></td></tr></table></figure></p>
<p><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/QQ20151019-0@2x.png" alt="正确配置"></p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天在我的个人托管在新加坡的VPS主机上上线了我的个人博客，因为我之前在这个VPS上上线过我之前的一个<a href="http://itodo.me">项目</a>, 也是通过nginx进行转发的。<br>而现在又要同样在<code>80</code>转发到我程序运行的端口，所以就要通过nginx配置文件中的<code>server_name</code>进行相应的转发，但是我在这里翻了一个错误，如果我自己不犯这个小错误<br>我就不会来写这篇小文章了。</p>]]>
    
    </summary>
    
      <category term="nginx" scheme="http://strucoder.com/tags/nginx/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[hexo加上github自动部署blog]]></title>
    <link href="http://strucoder.com/2015/10/17/hexo%E5%8A%A0%E4%B8%8Agithub%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2blog/"/>
    <id>http://strucoder.com/2015/10/17/hexo加上github自动部署blog/</id>
    <published>2015-10-17T14:41:54.000Z</published>
    <updated>2015-10-17T15:38:28.000Z</updated>
    <content type="html"><![CDATA[<h2 id="写在前面的话">写在前面的话</h2><p>今天折腾了一个上午，最后还是选定<code>hexo</code> 来最为我自己的blog, 说实在的，我为了能找到一个快捷，便利，设计大方的博客系统伤了好大脑筋，如果按照自己的想法自己写，又觉得自己的前端能力还不到家，达不到我想要的设计，或者说目前真心没有那么多的时间去做这个事，做一个实用<br>设计大方的博客，真不是一件容易的事，网上也有很多博客系统，但是很大一部分是基于<code>PHP</code>, 但是就我个人很不喜欢这个被很多人说为是世界上最好的语言，我也不知道为什么，我个人不喜欢一个语言没理由，所以不要拿什么和什么比。所以再三比较后，最后还是选用这个<code>hexo</code>, 并且写了一个简单的自动部署脚本.</p>
<a id="more"></a>
<h2 id="搭建自己的智能blog">搭建自己的智能blog</h2><p>在这里，我不假定你已经熟悉<code>Nodejs</code>, 有自己的<code>Github</code>, 了解<code>webHook</code> 以及 <code>markdown</code>. 并且有自己的<code>vps</code> 因为在自动化部署的时候用到，如果你对上面我所提到的有一个不清楚的话，你可以花一会去了解<br>一下，这样对于你阅读以下内容有一个好的铺垫。本文的<code>重点</code>讲利用<code>webHook</code>进行自动化部署，因为类似与如何用<code>hexo</code> 搭建自己的blog站点之类的文章，网上不胜枚举.<br>所以前半部分如果你很熟或者觉得我没有讲清楚，你可以去网上搜索。</p>
<h1 id="搭建blog">搭建blog</h1><h2 id="初始化hexo">初始化<code>hexo</code></h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br></pre></td></tr></table></figure>
<p>创建你的博客目录<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure></p>
<p>安装依赖<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> blog</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure></p>
<p>运行<br><figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo <span class="keyword">server</span></span><br></pre></td></tr></table></figure></p>
<h2 id="Github上创建存放博文的仓库">Github上创建存放博文的仓库</h2><p>将创建好的仓库的地址粘贴到<code>blog/_config.yml</code> 中，如下</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment"># Deployment</span></span><br><span class="line"><span class="comment">## Docs: http://hexo.io/docs/deployment.html</span></span><br><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  branch: master</span><br><span class="line">  repo: git@github.com:yourname/your-git-name.git</span><br></pre></td></tr></table></figure>
<p>在这同时通过<code>npm</code> 安装<code>npm install hexo-deployer-git --save</code>, 这个包就是为了提交服务的。</p>
<h2 id="站点地图以及Rss">站点地图以及Rss</h2><p>这个也不用我们去操心需要安装两个包</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-feed --save</span><br><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>安装完上面两个包后，你回发现每次运行<code>hexo generate</code>时在<code>public</code>目录下多处了<code>atom.xml</code> 和 <code>sitemap.xml</code>文件</p>
<h2 id="主题的选择">主题的选择</h2><p>你可以去<a href="https://hexo.io/themes/" target="_blank" rel="external">主题</a>上找到很多好看的主题, 或者去搜索引擎上搜索。很多很多。</p>
<h1 id="自动化部署">自动化部署</h1><h2 id="创建存放自己文章的仓库的webhook">创建存放自己文章的仓库的webhook</h2><p>在你的仓库页面的右边有一个设置的按钮，点击后到此仓库的设置界面。之后点击<code>webHook &amp; services</code></p>
<p><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/QQ20151017-1@2x.png" alt="图片1"></p>
<p>之后在<code>payload url</code>中填写你服务器给出的<code>URL</code>, <code>Content-type</code>选择不是<code>json</code>的那一个. 并且记住一定要写<code>secure</code>，保证安全的请求<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/QQ20151017-2@2x.png" alt="图片2"></p>
<h2 id="服务器自动化部署代码">服务器自动化部署代码</h2><p>在nginx上配置好自己的反向代理, 给大家一个我写的</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">  listen <span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">80</span>;</span><br><span class="line">  server_name     *.youdomain.com;</span><br><span class="line">  location / &#123;</span><br><span class="line">    proxy_http_version      <span class="number">1.1</span>;</span><br><span class="line">    proxy_<span class="built_in">set</span>_header        X-Real-IP       <span class="variable">$remote_addr</span>;</span><br><span class="line">    proxy_<span class="built_in">set</span>_header        X-Forwarded_For <span class="variable">$proxy_add_x_forwarded_for</span>;</span><br><span class="line">    proxy_<span class="built_in">set</span>_header        Host    <span class="variable">$http_host</span>;</span><br><span class="line">    proxy_<span class="built_in">set</span>_header        X-Nginx-Proxy   <span class="literal">true</span>;</span><br><span class="line">    proxy_<span class="built_in">read</span>_timeout      <span class="number">300</span>s;</span><br><span class="line">    proxy_pass      http://<span class="number">0.0</span>.<span class="number">0.0</span>:<span class="number">9002</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个我已经帮你写好了，见<a href="https://github.com/struCoder/blog-articles-server" target="_blank" rel="external">点击我</a>, 将这个代码部署到你的服务器，在运行前记得<code>cp config.example.js config.js</code>, 并且，将之前你在添加webhook时的密钥贴在这</p>
<p>在这个代码的跟目录运行</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:yourname/your-git-name.git public/articles</span><br></pre></td></tr></table></figure>
<p>上述的仓库也就是你创建存放你文章的仓库</p>
<p>初始化好后。我们可以在服务器上运行刚刚的程序.</p>
<h2 id="通过hexo部署">通过hexo部署</h2><p>在blog的根目录运行<code>hexo deploy</code> .运行成功后，我们可以去你自己的网站，看看是否是成功的。</p>
<h1 id="愉快的写博客">愉快的写博客</h1><p>在部署好我们的系统后，我们以后想写博客就可以在blog的根目录下运行<code>hexo new name</code>来创建一个blog了<br>如果你觉得你要写的可能会花很长的时间，你可以创建一个草稿<code>hexo new draft name</code>.在全部写完后运行<code>hexo publish draft name</code>, 之后你的草稿<br>就会从source<code>/_drafts</code> 到 <code>source/_posts</code> 最后运行<code>hexo generate</code> 就可以在网页里看到了。</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<h2 id="写在前面的话">写在前面的话</h2><p>今天折腾了一个上午，最后还是选定<code>hexo</code> 来最为我自己的blog, 说实在的，我为了能找到一个快捷，便利，设计大方的博客系统伤了好大脑筋，如果按照自己的想法自己写，又觉得自己的前端能力还不到家，达不到我想要的设计，或者说目前真心没有那么多的时间去做这个事，做一个实用<br>设计大方的博客，真不是一件容易的事，网上也有很多博客系统，但是很大一部分是基于<code>PHP</code>, 但是就我个人很不喜欢这个被很多人说为是世界上最好的语言，我也不知道为什么，我个人不喜欢一个语言没理由，所以不要拿什么和什么比。所以再三比较后，最后还是选用这个<code>hexo</code>, 并且写了一个简单的自动部署脚本.</p>]]>
    
    </summary>
    
      <category term="github" scheme="http://strucoder.com/tags/github/"/>
    
      <category term="nodejs" scheme="http://strucoder.com/tags/nodejs/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中国是不是二战的主战场-2]]></title>
    <link href="http://strucoder.com/2015/10/17/%E4%B8%AD%E5%9B%BD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E6%88%98%E7%9A%84%E4%B8%BB%E6%88%98%E5%9C%BA-2/"/>
    <id>http://strucoder.com/2015/10/17/中国是不是二战的主战场-2/</id>
    <published>2015-10-17T05:27:34.000Z</published>
    <updated>2015-10-17T05:37:09.000Z</updated>
    <content type="html"><![CDATA[<p>对于中国是不是二战的主张场2</p>
<p>很遗憾，不属于。</p>
<p>日军海陆精锐尽数席卷中国，这倒是不假，然而日军精锐既没有在中国战场受到重创，也没有精锐部队陷入中国战场而不能动弹。当太平洋战事吃紧时，<br>日军可以随时抽调任何一支他们想抽调的部队去支援太平洋战事，这一点上来看，在日军高层眼中，中国战场的重要性是次于太平洋战场的。<br><a id="more"></a><br>已经有人列出日军甲种师团的命运了，除了近卫师团镇守东京没来过中国之外，其他甲种师团都来中国参过战，却最终几乎全部命丧太平洋，这足以说明一点，<br>盟军歼灭日军的主战场是太平洋战场。而随着各支甲种师团调往太平洋，留在中国的部队是什么样的部队呢？大部分都是序号100以后的“特设师团”，<br>特设师团由甲种师团抽调一个联队加上预备役扩编组成，战斗力弱于甲种常备师团，然而还并不是日军最弱的部队。<br>最弱的部队是专为扫荡占领区而设立的丁种师团，该类师团不配备重型武器，也没有旅团，仅有四个步兵联队组成，人数11000人左右，兵员也都由临时征募的平民百姓组成，<br>就连军官也多是突击训练出来的，战力与战斗意志之弱，以至于一些日本军医回忆称，丙丁级别师团的士兵临死前不会高呼“天皇万岁”而是大喊“妈妈”，这样的部队充斥着大量不满20岁的孩子，或者就是拖家带口的中年人，根本无法与强悍的常备师团相媲美。</p>
<p>而这样的部队在中国战场有多少呢？1944年，中国派遣军一共有仅有56万人左右（华北22万，华中26万，华南8万），而1945年，由于菲律宾战役失败，<br>日军为防止美军登陆中国沿海，既而以中国为基地向日本本土进攻，同时为了打通大陆交通线，日军增强了中国派遣军的配置。到战败投降时，<br>中国派遣军+驻守台湾的第十方面军+越南北部驻军一共约110万人向国民政府投降。这里不得不说一下中国战场的一个变化，1944年3月，美军本有两套同时执行的计划，<br>分别为进攻菲律宾和台湾，两套方案并没有优先级之分，但是1944年9月，日军夺去了美军在华的36个机场和中国沿海的全部深水港，<br>这使得美军意识到没有来自中国大陆的空军支援和深水港用以停靠军舰，夺取台湾不仅损失很大而且并没有什么价值。<br>于是美军也就放弃了登陆中国再向日本进攻的计划，转而取道冲绳。这也就是说，直到1945年8月15日投降的那一天，<br>日军都能在中国完成任何他们想做到的战略计划。说阻止美军登陆，美军还真就没法登陆了。<br>另一方面也能看出，中国派遣军从1944年的56万人增兵到1945年将近90万人（减去台湾守军），兵力的增加并不是因为中国军队攻势增强，而是为了应对美军的登陆，再一次说明中国军队的存在感真的很低。</p>
<p>至战争结束时，中国派遣军+关东军+台湾守军+越南守军一共有70个乙种师团，30个丙种师团和20个丁种师团向国民政府投降，看番号数量还是不少的，<br>可是日军一共有多少个师团番号呢？一共使用了300个左右。也就是说，广义上的中国战场牵制了日本陆军三分之一的兵力，而陆航则几乎已经全部调往太平洋，<br>可以认为日本陆航基本上在中国没有任何主力部队了。严格来说，整个中国战场，仅有中国派遣军是用来对付中国军队的，关东军的主要任务是用来防御监视苏联，<br>因此不论关内打得多么火热，关东军始终保持着强于中国派遣军的实力而不轻举妄动。<br>关东军下辖31个步兵师团，11个步兵和坦克旅团，1个敢死队旅团和2个航空军，以及伪满洲国部队等，共约120万人，虽然战争后期关东军也大量抽调到其他战场，<br>不过关东军的规模始终是日军规模最大的总军之一。满员时的关东军是中国派遣军规模的1.5倍，而航空兵力和装甲兵力则远多于中国派遣军。<br>也可以说，国军和共军牵制的日军兵力还不如苏联远东方面军牵制的日军多。</p>
<p>关于中国军队的牵制能力有几成，有一个史实可以反映出来。1943年，日军参谋本部制定了夺取四川盆地的5号计划，该计划要求驻守武汉的第11方面军沿三峡进攻重庆，<br>而11方面军认为自己处于中国军队110个师的严密监视下，仅能自保，无力进攻。而11方面军有多少人呢？7个师团。中国是三三制编制，日本是四四制，<br>所以日本师团的人数相当于中国一个军的规模甚至可能还多，所以武汉方面对峙的兵力比应该在4:1左右。<br>那么日军攻取武汉投入了多少兵力呢？国府动员了14个集团军、50个军，作战飞机约200架，舰艇30余艘，总兵力近110万人，日军出动了14个师团，其中直接进攻的兵力有25万人。<br>武汉会战虽然战败，但是对日军造成了重大的伤亡，前后两组数据相比较，也就是说中国军队只有保持4:1以上的兵力优势才能对日军形成威慑。</p>
<p>正是因为中国军队只有具备极大的数量优势并付出极大的牺牲才能与日军一战，所以需要全体国人拿出破釜沉舟的勇气才足以与日寇抗争8年。<br>抗战8年是一件对我们自身很重要的事，这其中的重要性并不需要别人来承认，我们的牺牲也不需要一定对别人的胜利有价值才有意义。<br>中国战场对于其他盟国，对于整个二战来说并不一定非要放在很重要的位置才能满足我们对先烈的敬仰之情，他们的牺牲换取了同时代很多百姓的生存，<br>使我们的国家在一个国力数倍于我们的强敌面前仍然屹立不倒，这便已经是值得我们永远铭记的功勋了。如果为了肯定牺牲烈士们的功绩，<br>而硬要把中国战场说成是决定二战成败的一个因素，我认为这反而体现了这些人对牺牲的先烈的不尊重。这种情感，似乎是在埋怨先烈们杀的鬼子不够多，后辈们就用嘴炮补上吧。<br>那些抗日牺牲的将士们只要为中国的存亡做出了巨大的贡献，这便足够，抗日战争，首先是中国生死存亡的战争，其次才是世界反法西斯战争的一环。</p>
<p>所以我认为，以中国军队在抗日战争中的交换比，中国战场能牵制100万左右日军已经是极限，100万日本陆军也是日本能投入中国战场的兵力上限了。<br>日本投降时，其兵力达到最高峰，大约720万，其中向国民政府投降部队仅占日军总数15%，向苏联投降的关东军占总数8%，<br>剩下的部队基本上全用来应对美军向日本本土的进攻。至于罗斯福也好，斯大林也罢，对中国战场的评价本来就具有很浓厚的政治意义，在同样的敌人面前，<br>互相勉励自然是再正常不过的事了。就比如英美对苏联的物资援助，走的是北冰洋航线，且不说海面封冻对航线的影响，<br>驶过挪威海域时，最惨状态85%的商船毁于狼群潜艇和提尔比茨号战列舰（俾斯麦的兄弟舰）之手，<br>所有来自西方的战略物资仅占苏联军事物资的4%不到，即使如此杯水车薪的运输线，英美仍然坚持向苏联输送，为什么？这就是给盟友打气，传递一种大家是同一战线的信号。这些政治意义大于实际意义的事，不应该在军事层面上做过多解读。</p>
<p>即使中国投降了，日本也绝无可能攻向印度，苏联，中东。中国境内没有油田，最近的油田在婆罗洲，也就是说日本一定要跟英美荷拼命才能让战争机器转起来。<br>那么日本无论如何一定要消灭英国太平洋舰队和美国太平洋舰队，他才能坐稳亚太地区的资源。不然有没有中国，日本都会被困死。<br>所以英美试图用贸易禁令来制止日本对中国的侵略，侵略中国是日本走出困局的第一步，日本的野心从来就不止中国。<br>至于什么日本深陷中国战争泥潭所以才发动太平洋战争以夺取资源，这种说法就是本末倒置了。<br>29年全球经济危机时，日本眼看就要举国破产了，日元在国际市场如废纸一般屁都买不到，正是侵略满洲让日本经济续命了几年。<br>而经历了经济危机之后，各殖民大国想到的自救方法就是割断世界市场，各自在殖民地里建立贸易壁垒形成封闭的经济圈，于是德日这样的新兴工业国被排除在外，<br>那么发动战争，掠夺资源便是日本继续给自己续命的最优解，也可能是唯一解。所以中国战场本身并不是泥潭，日本自身的缺陷才是。事实上日本在39年时还试图消减中国派遣军的规模，这说明中国战场对于日本而言并不如我们想象的那么艰难。</p>
<p>补充点儿题外话，为什么说苏德战场是二战主战场呢？看看歼敌数据就知道了。苏德战场（苏联卫国战争），苏军共消灭和击溃德国及其盟国军队共607个师，<br>占德军及其盟军在整个战争中所损失的全部师数的77.5%以上。德军（含党卫队）在苏德战争中损失累计约1300万人。<br>其中死亡381.74万人、被俘250万人（不含1945年5月9日后投降或受降的120多万德军），被俘后死亡36.33万人、伤病累计700多万人。<br>最终死亡人数为418万（含死亡的俘虏）。以上数据包括奥地利、苏台德地区、阿尔萨斯等地的德意志人。另外，德国仆从国军队，有超过100万人死于东线对苏作战。</p>
<p>四分之三的德军被苏联消灭，那么东线当然是决定整个世界大战成败的主战场了。虽然苏联付出了2000余万人伤亡，然而苏联的巨大贡献不是因其牺牲大，<br>而是其歼敌数量大。中国虽然有大量人口损失，然而歼敌数量是硬伤，这就不足以成为主战场。</p>
<p>更多详情: <a href="http://www.zhihu.com/question/24648753/answer/61961012" target="_blank" rel="external">http://www.zhihu.com/question/24648753/answer/61961012</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于中国是不是二战的主张场2</p>
<p>很遗憾，不属于。</p>
<p>日军海陆精锐尽数席卷中国，这倒是不假，然而日军精锐既没有在中国战场受到重创，也没有精锐部队陷入中国战场而不能动弹。当太平洋战事吃紧时，<br>日军可以随时抽调任何一支他们想抽调的部队去支援太平洋战事，这一点上来看，在日军高层眼中，中国战场的重要性是次于太平洋战场的。<br>]]>
    
    </summary>
    
      <category term="历史" scheme="http://strucoder.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="战争" scheme="http://strucoder.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[中国是不是二战的主战场-1]]></title>
    <link href="http://strucoder.com/2015/10/17/%E4%B8%AD%E5%9B%BD%E6%98%AF%E4%B8%8D%E6%98%AF%E4%BA%8C%E6%88%98%E7%9A%84%E4%B8%BB%E6%88%98%E5%9C%BA-1/"/>
    <id>http://strucoder.com/2015/10/17/中国是不是二战的主战场-1/</id>
    <published>2015-10-17T05:18:19.000Z</published>
    <updated>2015-10-17T07:31:15.000Z</updated>
    <content type="html"><![CDATA[<p>对于中国是不是二战的主战场1</p>
<p>前几天还能在人民网，新华网，观察者网上看到这篇文章，今天一查全被删了。估计是和这几天主旋律不符，但其实没必要。文章很客观的。首先我要说中国肯定是主战场，然后看文章吧。</p>
<p>徐焰:抗日战争的真实战况</p>
<p>徐焰，国防大学战略教研部教授，少将军衔，军事史专家。</p>
<a id="more"></a>
<p>中国在上世纪进行的抗日战争，几十年来一直是激发爱国主义精神的重要教材，这是应当也是必然的。不过，在一段时期，宣传口径根据政治形势的需要存在一定的片面性，这使得今天遇到现实争端时产生了困惑。<br>例如钓鱼岛争端加剧后，人们愤慨“战败国”敢占“战胜国”之地，对内还产生诸如“软弱”一类的指责。由于多年来国内强调突出“正面教育”，强调中国才是打败日本的主力军，结果反而引来不少人的疑问——既然如此，为何日本不肯谢罪甚至其政要多不承认侵略？为何中国要放弃对日本要求赔款？<br>如今，人们已能接触到多方面的信息，对当年那种片面的“正面教育”已不易全面接受，大量“愤青”的出现恰恰是对僵化教育的逆反。客观地说明当年中国抗战胜利存在的某些局限性，多数人才能冷静客观地正视中日矛盾的历史由来，从而在目前的争端中以理性的态度爱国。</p>
<h2 id="1、毛泽东对中国抗战的作用有很客观的评价">1、毛泽东对中国抗战的作用有很客观的评价</h2><p>在很长时间内，中国因积贫积弱，为振奋民气往往希望突出自己的战绩。例如一些宣传口径强调，抗战时中国战场是东方反法西斯战争的主战场，中国是打败日本侵略的主力军。这种说法虽反驳了西方贬低中国抗战作用的论调，歌颂了当年抗战军民的功绩，不过严格而论却不太准确。事实上，毛泽东在接待外宾时的讲话，对中国抗战的作用有很客观的评价。<br>1956年9月24日，毛泽东同参加中共第八次全国代表大会的南斯拉夫共产主义者联盟代表团谈到中国在抗战中的作用时说过：“第二次世界大战中我们是一个支队，不是主力军。”（《毛泽东文集》第七卷，人民出版社1999年版）当年中国太贫弱，虽有大国之名却无大国实力，只是以持久战拖住日本。世界上打败法西斯的主力军是谁呢？从实力看还是苏、美、英三国。<br>过去一些正面教育的口径，恰恰违背了毛泽东这一客观评价。国内有些人着力宣传抗战重大意义的动机虽是好的，却不谈中国因贫弱而导致战力有限。至于宣传“主力军”、“主战场”而引用的一些数据，按科学的史学态度来分析并不严谨，甚至存在偷换概念的错误。<br>如有些人搞不清军语中“死亡”与“伤亡”是不同概念，将中国“伤亡”3500万人（其中死亡2000余万人）说成“死亡3500万人”，并就此说中国超过苏联是二战中牺牲最大的国家。殊不知苏联宣布的牺牲2700万（俄罗斯有一数据是2650万），是纯粹的死亡数，并没有加上2000万以上的负伤数字，苏联才是二战中牺牲最大的国家。<br>有人统计中国战场上消灭日军的数字，是根据日本战后承认在关内战场累计伤亡了133万（战时日军极少有人被俘），加上在东北战场和中国人在缅甸战场上的战果，得出了“消灭日军150万人”的数字。这一算法虽有其根据，却忽略了日军伤员治愈后重返战场的人数，并不完全准确。<br>按照战争统计学的原则，对一场战斗或战役消灭敌军的统计，可以把死、伤、病、俘相加，这是敌人的净减员数。对一场持久的战争的歼敌数若是按每场战役、战斗的总数相加，往往会造成大量重复统计而高于实际数，这是因为伤病员过一段时间多数能归队。例如有时一个士兵在一场战争会负伤多次，若将此人在各次战役的击伤数累计，几人的数字其实就是一个人。<br>因此，若要科学地计算一场持久战争中一个国家的损失，应该计算的是其“不可弥补损失”，即死亡、被俘（而且是未释放的）或重伤残废者的累计。<br>前些年一些宣传抗战成果的文章中，列举出一个所谓中国战场消灭日军占日本战争中军队损失“三分之二”的虚夸比例。从统计学角度看，这个比例是用偷换概念的方式（把“伤亡”与“死亡”两个不同概念混淆后相对比）算出来的，即用中国军队造成日军150万人的“伤亡”同日军战争中总“死亡”212万人相除。其实按可比的数据看，中国战场上日军的死亡共45万人，只占其战时死亡总数的22%。<br>1941年太平洋战争爆发前，日本仅有中国这一个交战国，另有苏联这个发生过局部战事却主要采取军事对峙的潜在敌国，还可以说中国是东方对日作战的主战场。太平洋战争爆发后四年间，中国战场在反法西斯战争中的作用确如毛泽东所说的，只是“一个支队”。
　　</p>
<h2 id="2、对日作战美国展示了最强实力，战后处置日本才掌握了主导权">2、对日作战美国展示了最强实力，战后处置日本才掌握了主导权</h2><p>包括中国抗战史在内的战争史证明，不仅落后就要挨打，而且落后和衰弱的国家即使获得战胜国地位，最终也没多少发言权。国人感到悲哀的是，抗战胜利前夕美英苏三国商议战胜日本后的利益分配时，居然拿中国的领土权益（包括外蒙古问题）做了交易，国民党政府还不得不屈辱地接受，导致战胜国的领土损失面积比战败国还大。<br>在战争问题上的发言权，最终靠实力决定。中国在抗战时国力衰弱，掌国柄的国民党政权腐败无能（当时连美国政府也这样认为），中国共产党领导的军队还多数是游击性质的部队，这就决定了对日作战主要是以持久战方式拖住对手。<br>中国是同日本作战最久的国家，早在太平洋战争开始前十年即1931年“九一八”事变后，便在东北开始了局部抗战。1937年日本在卢沟桥战事后曾叫嚷“三个月解决支那事变”，以为能速战速决征服中国，结果深陷泥潭，虽占领了大半个中国，却在正面战场受国民党军抵抗，后方又有共产党游击队袭扰，拖了八年不仅不能取胜也无法自拔。不过，中国因力量衰弱，在日本战败前也无力实施全面反攻。<br>看一下日本宣布投降时中国的战略要地如北平、上海、南京、武汉、广州等地，<br>还都在日本占领之下，这种战场形势与“胜利者”的地位相符吗？客观地讲述这段历史，应说明中国1945年战胜日本是在国际反法西斯战争的大背景下取得的，不能单讲本国战场的作用。<br>过去宣传抗战，一些口径从现实政治需要出发，带有片面性和虚夸性。如国民党当局在抗战时宣布的战果往往充满吹嘘，对一溃千里等败绩则尽量掩饰。新中国成立后因与美国对立并需要强调“人民战争”的威力，较少谈美国在太平洋战场的战绩，<br>而把地道战、地雷战等游击战描绘成打败日军的主要方式。改革开放后，大陆方面对国民党抗战给予了肯定，不过一些媒体又袭用台湾书籍中的吹嘘资料，对整个中国战场的作用大力抬高。<br>这种教育对振奋民族精神也许有些作用，但从长远看却会使相当多人对此类宣传从整体上产生不信任感，使他们反而容易听信反面的歪曲宣传。<br>仔细研究日本在二战中的兵力分布，可看出它因轻视中国而在多数时间未投入主力。<br>日军只是在1940年之前的两年把多数陆军师团投入关内，针对苏联的关东军却保持着最精锐部队（对付满洲的抗日游击队主要使用伪军、伪警），军费投资重点又是准备对美英作战的海军。日本因工业和财力落后于西方强国，有限的投入只能保证其航空兵和战舰达到世界先进水平，陆军装备远远落后于美英苏德等国。1941年日军偷袭珍珠港后，不仅几乎全部海军投入对美作战，陆军精锐也陆续投入南洋。<br>看一下战争末期日军的兵力分布：在本土和南洋对付美、英的兵力为550万，在满洲和朝鲜对抗苏联的兵力为92万，在中国战场（当时伪满地区不包括在这一战场）兵力为110万。若说中国是当年对日战争的“主战场”，公正地讲应在后面加上“之一”。<br>如果查一下日本在战争中的损失，大多数也是美军造成。战时日本假报过数字，战后其靖国神社却能查到每个战死者的灵牌，加上政府要按实数发抚恤金，其厚生省统计185万军人战死（如加上此后拘押中的死亡则总数达213万）是准确的。具体看一下死者分布：日军在中国关内八年作战死亡为40万（宣布投降后又死亡了5万人）。<br>日军在满洲死亡共9万，绝大多数系苏军造成。在缅甸死亡16万，除少数为中国远征军击毙外，多数系英军造成。其余120万“战殁者”，都死于同美军交战的太平洋战场，其中在菲律宾便死了49万。<br>美军在太平洋岛屿战中能大量击毙日军，并成建制全歼日本不少军、师团单位（这样其伤病员也大多会死亡），是因为美军拥有占绝对优势的火力和技术装备。中国军队对日军一般只能零打碎敲，<br>没有全歼过一个师团、一个旅团，连歼灭联队（团）级单位也仅在腾冲这样的个别地区出现过。<br>保全了建制的日军，便能将大量伤病员后送治疗，各部队经补充也能恢复战力。至于海战方面，当年中国海军未打过一次海战便自沉，空军力量也弱，战争中没有击沉过一艘日本大中型战舰。日本海军的几十艘战列舰、航空母舰和巡洋舰绝大多数都沉入海底，又基本上是由美军造成。<br>过去一些宣传说苏联军队“歼灭了日本关东军”，从史实看也不大准确。苏军确实长期牵制了日本关东军主力，最后宣战又对日本形成了比原子弹爆炸更大的震慑，使日本御前会议于苏联参战次日作出在保留天皇制的条件下投降的决定。<br>若从战场实际看，苏军对日作战仅八天，关东军在主力尚存的情况下即奉命停止抵抗，随后苏军即转入“受降”而不是“歼灭”作战。苏联对日作战出力虽不算多，却在处置日本时比中国有更大发言权，这恰恰是其国力军力远强于中国的体现。<br>日本除了在海外战场遭受重大损失，本土也遭受了猛烈轰炸，包括落下两颗原子弹，这些全系美军造成。中国在抗战时没有攻击日本本土的能力，苏军出兵只攻击了满洲、朝鲜和日本北方岛屿（按苏联讲法这些岛原来曾属俄罗斯）。<br>日本宣布投降时，只有拥有强大海军的美军能够开入日本境内并单独实施占领。了解这些历史事实，就会明白美国在打败日本时展示了最强的力量，战后在处置日本时也就掌握了主导权。</p>
<h2 id="3、正视国家病弱才能客观看待历史，振奋民族精神要靠科学理念">3、正视国家病弱才能客观看待历史，振奋民族精神要靠科学理念</h2><p>国家的现代化，很大程度上又是理性化。一个民族要振奋人心、凝聚内部，自然需要突出英雄主义和宣传自己的战绩，不过对自身的历史病弱和败绩也不应回避，如同古人所说的那样——“知耻近乎勇”。历史从来是多棱镜，国人对抗战史要从多个角度看，才能知道中国民族解放斗争的艰难；同时了解民族的传统病弱，如此方能以更为理性的教育鞭策后人为强国梦而努力。<br>客观地回顾抗战，首先要看到当时的中国是四分五裂且非常落后的农业国，面对工业强国日本的大举入侵，能够坚持八年全面抗战，最后与国际反法西斯同盟一起将日本打败，众多志士仁人的英勇奋斗确实值得后人大力颂扬。如今国人歌颂抗战英雄，主要应弘扬他们顽强持久奋战的精神，夸大战绩则属画蛇添足。<br>讲抗战史又不能避开当时中国的病弱，这不仅体现为经济和科技水平落后，也表现为当政的国民政府的腐朽。<br>如南京保卫战时11万守军面对同等数目的日军进攻，仅5天便全军崩溃且官兵乱跑，结果多数人当了俘虏惨遭屠杀。国人应谴责日军在南京屠城的暴行，同时不能回避守军保国卫民的无能。再如抗战期间以国民党副总裁为首的大批军政官员投日组织伪政权，政府军有60万人降敌变成伪军，这种民族耻辱是不应讳言的事实。<br>抗战结束前夕，日本在太平洋战场大势已去，在中国战场的强势地位却并未改变，1944年春至1945年初“打通大陆交通线”攻势仍将国民党军打得败退千里。<br>此时美国总统罗斯福认为中国战场可能崩溃，急于请求苏联参战，因而在雅尔塔会议上用中国领土权益同苏联做交易。战后不少日本人认为“只败给了美国”，对中国不肯服气，原因不言自明。<br>现代科学要注重定量分析，战史分析的科学性应体现为准确考证战绩和损失数，不能使用夸张或歪曲的资料。从数据分析可以看出，全面抗战开始前中国政府统治区年产钢不过4万吨，日本却达580万吨。当时中国处于四分五裂状态而对国民产值无法统计，<br>1936年国民政府财政收入仅为可怜的11.9亿元法币（折合4亿美元），同年日本财政收入则超过100亿日元（折合30亿美元）。<br>再看当时美国的实力，又远非中日两国可比。美国战时年最高钢产量超过8000万吨，年财政收入达1000多亿美元。战争中实力对比是决定因素，中国作为战胜国享受不到应有待遇，还受到其他盟友欺凌，其原因只有用定量分析才能解释。<br>若不进行定量分析而只搞定性宣传，对抗战的战果加以夸张，就会顾此失彼、自相矛盾。<br>例如许多国人就不理解：为什么战败的日本对中国不服气且长期否定侵略罪责呢？中国为什么无法得到日本的赔款最终只好放弃呢？了解美国的实力及其单独控制日本的实际，人们才会明白，1948年美国宣布日本可免除赔款义务后，苏联、英国和中国国民党当局看到索赔无望只好放弃，1972年中国政府在对日邦交时也不能不承认这一难以改变的事实。<br>作为战胜国的中国在处置日本时没有多少发言权，也就难以索回一些丧失的领土权益。例如原属台湾的钓鱼岛在1895年马关条约后落入日本之手，<br>抗战胜利后由美军控制而未归还中国。1970年美国在向日本“归还冲绳”时，又将此岛交给日本管理。1972年中日恢复邦交时，毛泽东、周恩来决定对钓鱼岛问题予以搁置，邓小平和后来的中国领导人也沿袭这一决策。2012年日本政府在钓鱼岛问题发难激化矛盾时，许多国人尤其是年轻人不知道中国当年虽有战胜国之名，却未收回那片岛屿的事实，误以为是现在“受欺负”。<br>过去几十年宣传教育的事实证明，只有正面教育或片面的解说，会导致受教育者在思想上非常脆弱且经不起风浪，一旦遇到现实与正面宣传不相符，便会出现大批偏激的充满狭隘民族主义情绪的“愤青”。同样，如果不搞正面宣传，否定当年的奋斗史且一味贬低先辈，又会导致媚外和民族虚无主义。看一下如今社会的思想状况，恰恰是这两种倾向都在滋长，这又能从另一个角度看出全面、科学地宣传历史的重要性。</p>
<h2 id="4、当年未能让日本对战争悔罪，如今只能以自强处理中日关系">4、当年未能让日本对战争悔罪，如今只能以自强处理中日关系</h2><p>国家间的关系，最终以实力和利益来决定。1945年以前的半个世纪间，日本不断侵略和欺负中国，战败后又长期不承认侵略罪行，关键因素是中国实力不济，实力最强的美国又在战后多方庇护日本。<br>许多国人多年来总是愤慨于日本政要大都否认侵略罪行且参拜靖国神社，不理解为何德国能深入反省历史日本却不能。要明白其中的原因，不能不客观地回顾历史。<br>对传统说法“日本无条件投降”的宣传再做深究，就能看到当年天皇接受波茨坦公告其实是有条件的，那就是“保留国体”。美国从减少自身伤亡和战后牵制苏联的战略需求出发，对此表示同意，<br>导致头号战犯天皇裕仁及其重臣继续在位，甲级战犯岸信介（即现在的首相安倍晋三的外祖父）战后还长期任首相。直至现在，日本政要中很大一部分都是这些战犯的后人，他们怎么可能清算当年的侵略罪行？<br>对比1945年德国和日本战败的情况，可看出其根本区别在于纳粹政权已被盟军彻底消灭，战后的东德、西德政权都是盟国扶起的原反法西斯人士执政。日本战败后，元首和政府却都保留下来，<br>战后只是听命于美国，对内政进行了一些“民主改革”。蒋介石在大陆失败后，美国又把建立美日军事同盟视为亚洲政策的基石，为此实行在政治上、经济上扶助日本的政策。<br>1951年美国主持的旧金山和会，便把中国排除在外，这个会议通过的对日和约只谈让日本放弃南海岛屿、台湾，而不谈将其归还中国，这就种下了“台独”和南海争端的种子。<br>由于有美国大力帮助，1950年日本的经济产值便超过100亿美元而恢复战前最高水平，1970年更超过2000亿美元。<br>因此，日本当局和相当多国民对打败自己又加以扶植的美国又敬畏、又感激，对华态度则始终追随美国。由于美日军事同盟对新中国构成最大战略威胁，毛泽东那一代领导人考虑对日政策，主要是争取日本人民，以削弱日美同盟关系。<br>战后美国单独占领日本，如何追究战争责任实际由美方最后决定。战争刚结束时，重建的日本共产党和一些左翼派别曾在国内发起过清算天皇、财阀战争罪行的运动，<br>却受占领军压制，而多数国民则依旧受神道教思想束缚，故这场运动只造成些声势而未收到多少实效。1946年至1948年东京审判的对象主要限于“光头军阀”，虽追究了东条英机等一些次要战犯（有人把东条英机说成“二战三元凶”是不了解日本战时历史），却放过了最主要的战犯，而且没有清算当年在侵略战争起支柱作用的财阀。战后日本政界仍由这些财阀起主要作用，这也决定了日本的政治走向必然持续右倾化。<br>自上世纪50年代起，日本出现了持续几十年的“经济起飞”，民众生活水平大幅提升，左翼运动在70年代后逐渐陷入低潮，右翼势力却依仗着经济底气重新滋长。<br>看到这种难以改变的事实，苏联最先于1956年恢复对日邦交，不再提战争遗留问题（苏方在北方四岛已占了便宜也不愿再谈）。中国1972年对日复交时，也只能从现实出发。后来中国政府和民间虽经常提到日本侵华暴行，对一些日本人否定南京大屠杀加以驳斥，却也不可能改变日本政府和社会主流的历史观。<br>追溯二战结束时的历史可以看出，若想让日本社会清算并真正承认侵略罪行，必须在战后清算各级战犯并改变当权者。由于美国的包庇和日本社会的局限，这一历史机遇业已丧失。<br>现在经历过战争的一代人多已不在世，就普通日本民众而言，部分老年人还存留一点对华歉疚感，中青年则大都不愿再追究当年的战争责任。<br>看一下上世纪70年代至90年代日本的民间测验，对中国有好感的人比例还较高。从上世纪90年代末至现在，日本民意测验显示对中国有好感的比例在降低，重要原因就在于年轻一代对华没有负疚感，且认为本国受中国打压。当然，日本出现这种社会思潮，根源又在于其当政者对中国崛起的不安，因而进一步追随美国并煽动反华情绪。<br>历史作为一面镜子，总是由今人来照。在明治维新和甲午战后，“日强中弱”的形势导致日本几十年持续侵华。当年中国取得抗战胜利，却因国力衰弱并未赢得战败者的尊重。<br>战后日本在军事上虽无独立地位，却在经济上长期对华居于优势，结果中日邦交恢复后中国曾处于受援国地位。<br>现在中国实力增强使得亚洲出现了中日“两强并立”，2010年中国经济总量超过日本，刺激了日本当权者要加强同美国的联盟。由此看来，近年中日关系出现的紧张恰恰说明了中国已经崛起，并真正让日方有了些敬畏心理。对一向有着崇强凌弱传统的日本来说，中国越发展、越强大，才能真正获得它的尊重。我国国内对抗战史的回顾和宣传，也要努力做到全面客观，这才有助于国人以更科学、理性的方式认识中日关系。</p>
<p>更多详情: <a href="http://www.zhihu.com/question/24648753/answer/62153793" target="_blank" rel="external">http://www.zhihu.com/question/24648753/answer/62153793</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>对于中国是不是二战的主战场1</p>
<p>前几天还能在人民网，新华网，观察者网上看到这篇文章，今天一查全被删了。估计是和这几天主旋律不符，但其实没必要。文章很客观的。首先我要说中国肯定是主战场，然后看文章吧。</p>
<p>徐焰:抗日战争的真实战况</p>
<p>徐焰，国防大学战略教研部教授，少将军衔，军事史专家。</p>]]>
    
    </summary>
    
      <category term="历史" scheme="http://strucoder.com/tags/%E5%8E%86%E5%8F%B2/"/>
    
      <category term="战争" scheme="http://strucoder.com/tags/%E6%88%98%E4%BA%89/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[javascript实现编辑距离]]></title>
    <link href="http://strucoder.com/2015/07/18/javascript%E5%AE%9E%E7%8E%B0%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB/"/>
    <id>http://strucoder.com/2015/07/18/javascript实现编辑距离/</id>
    <published>2015-07-18T03:09:00.000Z</published>
    <updated>2015-10-18T03:19:05.000Z</updated>
    <content type="html"><![CDATA[<p>我还在学校的时候写过这<a href="http://www.cnblogs.com/struCoder/p/3462357.html" target="_blank" rel="external">一篇文章</a>, 在这篇文章里就初步的<br>利用别人写好的算法(编辑距离)来实现当初自己想做的东西，目前因为自己很多时间在用javascript, 所以在这篇文章里用js来实现一个<strong>编辑距离</strong>.</p>
<a id="more"></a>
<h2 id="什么是编辑距离">什么是编辑距离</h2><p>编辑距离:  又称Levenshtein距离(也叫做Edit Distance)，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数，如果它们的距离越大，说明它们越是不同。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。</p>
<h2 id="编辑距离的作用">编辑距离的作用</h2><ul>
<li>验证码识别</li>
<li>检测文章的相似度</li>
<li>文档的重写度</li>
<li>…</li>
</ul>
<h2 id="算法的实现步骤">算法的实现步骤</h2><ol>
<li>两个字符串中如果有一个字符串的长度为0则返回另一个字符串的长度</li>
<li>初始化一个(lenStr1 + 1) * (lenStr2 + 1)二维数组, x轴与y轴以0开始到lenStr(1|2)</li>
<li>取dArr[i][j-1],  dArr[i - 1][j] 和dArr[i - 1][j - 1] + str1[i - 1] === str2 [j - 1] ? 0 : 1 中的最小数作为dArr[i][j]</li>
</ol>
<h2 id="代码实现">代码实现</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> getStrDistance = <span class="function"><span class="keyword">function</span>(<span class="params">str1, str2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> lenStr1 = str1.length;</span><br><span class="line">  <span class="keyword">var</span> lenStr2 = str2.length;</span><br><span class="line">  <span class="keyword">if</span> (lenStr1 === <span class="number">0</span> || lenStr2 === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> lenStr1 === <span class="number">0</span> ? lenStr2 : lenStr1;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> dArr = <span class="keyword">new</span> <span class="built_in">Array</span>(lenStr1 + <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt;= lenStr1; i++) &#123;</span><br><span class="line">    dArr[i] = <span class="keyword">new</span> <span class="built_in">Array</span>(lenStr2 + <span class="number">1</span>);</span><br><span class="line">    dArr[i][<span class="number">0</span>] = i;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt;= lenStr2; j++) &#123;</span><br><span class="line">    dArr[<span class="number">0</span>][j] = j;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> k = <span class="number">1</span>; k &lt;= lenStr1; k++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> l = <span class="number">1</span>; l &lt;= lenStr2; l++) &#123;</span><br><span class="line">      dArr[k][l] = <span class="built_in">Math</span>.min(</span><br><span class="line">        dArr[k - <span class="number">1</span>][l - <span class="number">1</span>] + (str1[k - <span class="number">1</span>] === str2[l - <span class="number">1</span>] ? <span class="number">0</span> : <span class="number">1</span>),</span><br><span class="line">        dArr[k - <span class="number">1</span>][l] + <span class="number">1</span>,</span><br><span class="line">        dArr[k][l - <span class="number">1</span>] + <span class="number">1</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> dArr[lenStr1][lenStr2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/xaL6fMpsmiHG8LQmX.png" alt="运行结果"></p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>我还在学校的时候写过这<a href="http://www.cnblogs.com/struCoder/p/3462357.html">一篇文章</a>, 在这篇文章里就初步的<br>利用别人写好的算法(编辑距离)来实现当初自己想做的东西，目前因为自己很多时间在用javascript, 所以在这篇文章里用js来实现一个<strong>编辑距离</strong>.</p>]]>
    
    </summary>
    
      <category term="javascript" scheme="http://strucoder.com/tags/javascript/"/>
    
      <category term="算法" scheme="http://strucoder.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[通过声音破解案按键数字]]></title>
    <link href="http://strucoder.com/2015/05/18/%E9%80%9A%E8%BF%87%E5%A3%B0%E9%9F%B3%E7%A0%B4%E8%A7%A3%E6%A1%88%E6%8C%89%E9%94%AE%E6%95%B0%E5%AD%97/"/>
    <id>http://strucoder.com/2015/05/18/通过声音破解案按键数字/</id>
    <published>2015-05-18T03:32:23.000Z</published>
    <updated>2015-10-18T03:36:16.000Z</updated>
    <content type="html"><![CDATA[<p>关于手机(电话)拨号按键声音破解</p>
<h2 id="做这件事的原因">做这件事的原因</h2><p>今天不知道什么时候的突发奇想，居然想到了以前听别人说，可以通过按键声音的不同从而可以在只听别人拨号时发出的声音而知道，这个人按了那些<br>键，这个咋一听感觉非常奇妙，但是像我们这些，对声音不怎么敏感的码农又如何做到可以听声晓键的至高境界呢。当然通过软件以及相关知识。<br><a id="more"></a></p>
<h2 id="准备工作">准备工作</h2><ol>
<li>了解多音双频的概念(大致了解一下就好)</li>
<li>下载Adobe公司的<strong>Adobe Audition</strong>(网上有绿色版)</li>
<li>对照电话按键的频谱表(后面我会给大家)</li>
<li>自己手机录一段声音(我这里给大家提前录好了，我是用iphone录的魅族3的拨号音.可以下载)</li>
</ol>
<h2 id="开始破解">开始破解</h2><p>首先打开Adobe Audition并且将<a href="http://pan.baidu.com/s/1mgvglnE" target="_blank" rel="external">这个文件</a>打开, 之后你会看到类似于这样的频谱图<br> <img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/GTey2G4tmXtdgAdy7.png" alt="1.png"></p>
<p>看到这样的东西一定觉得特别炫，我今天因为首次搞这个也是第一次见到，直接炫呆了。之后，我们将窗口中下方的<code>频谱</code>区域调大一些，就是拖拽<br>频谱图与波形图之间的分隔栏。<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/GTey2G4tmXtdgAdy7.png" alt="2.png"><br>紧接着我们稍微将鼠标移动到<code>频谱图</code>中滚动滑轮进行放大以及，将鼠标移动到右侧中的<code>频率</code>上滚动滑轮，此时我们就可以看到如下的效果了<br><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/3gPgbJ5L77wLQpgEK.png" alt="放大后"></p>
<p>之后通过对照电话按键的<code>频率表</code></p>
<p><img src="http://7xjbiz.com1.z0.glb.clouddn.com/blog/QxfNnbx3k68a4isNQ.png" alt="多音双频.png"></p>
<p>相信你一定得到开始我们录音时的电话按键了，我的是<code>85698</code></p>
<h2 id="最后">最后</h2><p>本次突发奇想的去做这个事尽是而然性，大家也可以通过这个去算出，那些电视节目里拨打号码的场景，可以算出，那些人究竟拨打了那些数字<br>或者说是不是真正的拨打了有效的电话。哈哈</p>
<p>完.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>关于手机(电话)拨号按键声音破解</p>
<h2 id="做这件事的原因">做这件事的原因</h2><p>今天不知道什么时候的突发奇想，居然想到了以前听别人说，可以通过按键声音的不同从而可以在只听别人拨号时发出的声音而知道，这个人按了那些<br>键，这个咋一听感觉非常奇妙，但是像我们这些，对声音不怎么敏感的码农又如何做到可以听声晓键的至高境界呢。当然通过软件以及相关知识。<br>]]>
    
    </summary>
    
      <category term="Adobe" scheme="http://strucoder.com/tags/Adobe/"/>
    
      <category term="折腾" scheme="http://strucoder.com/tags/%E6%8A%98%E8%85%BE/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[meteor-SEO经验-分享]]></title>
    <link href="http://strucoder.com/2015/05/18/meteor-SEO%E7%BB%8F%E9%AA%8C-%E5%88%86%E4%BA%AB/"/>
    <id>http://strucoder.com/2015/05/18/meteor-SEO经验-分享/</id>
    <published>2015-05-17T19:21:37.000Z</published>
    <updated>2015-10-21T08:24:39.000Z</updated>
    <content type="html"><![CDATA[<p>Meteor的SEO经验分享</p>
<h2 id="对Meteor_SEO的探索:">对Meteor SEO的探索:</h2><p>在<a href="http://www.itodo.me/u/p/detail/cTqYKYJbfLPs3kR6Y" target="_blank" rel="external">这篇文章</a>里我就已经对Meteor的SEO做了一次<br>探索性的总结，因为目前很多老外或者官网都推荐<a href="https://atmospherejs.com/meteor/spiderable" target="_blank" rel="external">这个spideable</a>包，我刚开始也跟着 官网的推荐尝试了一下，各种坑啊，那个<code>phantomjs</code>在这里做为后端编译然后<br>返回<code>html</code>给爬虫，简直是大材小用，更为主要的是，这个<code>phantomjs</code>太大了，而且我没有编译成功，这也是导致我放弃的原因，因为我们要解决meteor 的seo的根本思想就是，后端将渲染好的页面返回给爬虫。本着这个思想，我在<a href="https://atmospherejs.com" target="_blank" rel="external">package官网</a>也找了一下，最终找到了我想要的包也就是<a href="https://atmospherejs.com/meteorhacks/ssr" target="_blank" rel="external">srr</a>. 这哥们的源码我也看了，几乎是基于<code>Meteor</code>内在的代码，对其它代码的依赖很小，这才是我想要的。</p>
<a id="more"></a>
<h2 id="关于Meta">关于Meta</h2><p>一般情况下，爬虫爬你的网站，对于Meta的认识还是非常重要的，如果你在你单页web应用的头部表明：<br><code>&lt;meta name=&quot;fragment&quot; content=&quot;!&quot;&gt;</code>这样爬虫就知道你的网站是单页应用，他就会重新以新的方式再次请求你的网站, 比如开始请求你的网站:www.itodo.me. 当看到刚刚写的那个meta时，其从新以<br><code>www.itodo.me/?_escaped_fragment_=</code>的形式请求的你网站，如果我们知道爬虫这样的行为，接下来的事就好办了我们可以在<code>sever</code>代码里判断其query，针对<code>Meteor</code>我们可以用<code>webapp</code>或者<code>iron:router</code>进行<code>query</code>判断.在这里我就以<code>iron:router</code>来表述我的SEO做法.</p>
<h2 id="我的Meteor_SEO">我的Meteor SEO</h2><p>按照<code>meteorhacks:ssr</code>的文档，我在根目录新建一个<code>srr</code>文件夹具体的目录结构为:<br>&gt;<br>  |–srr<br>    |–server<br>      |–compile.js<br>      |–serverrRouter.js</p>
<p>在我的<code>private</code>目录下就是我们想给爬虫的那些页面了。动态渲染的有<code>\{\{title\}\}</code>, <code>\{\{description\}\}</code>和<br><code>\{\{content\}\}</code>这三个我想是必须的而且对于爬虫来说，更是尤其重要的内容.<br>这是我在<code>serverRouter.js</code>中的部分代码，不过很典型<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Router.route(<span class="string">'/u/p/detail/:id'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req, res, next</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="regexp">/_escaped_fragment_/</span>.test(req.url)) &#123;</span><br><span class="line">    <span class="keyword">var</span> noteId = <span class="keyword">this</span>.params.id;</span><br><span class="line">    <span class="keyword">var</span> oneNote = Notes.findOne(xxx)</span><br><span class="line">    <span class="keyword">if</span> (!oneNote) &#123;</span><br><span class="line">      <span class="keyword">return</span> res.status(<span class="number">404</span>).end();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> oneNoteHtml = SSR.render(<span class="string">'detail'</span>, &#123;</span><br><span class="line">      css: css,</span><br><span class="line">      title: oneNote.title,</span><br><span class="line">      description: oneNote.note.substring(<span class="number">0</span>, <span class="number">300</span>),</span><br><span class="line">      oneNote: oneNote</span><br><span class="line">    &#125;);</span><br><span class="line">    res.writeHead(<span class="number">200</span>, &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'text/html'</span></span><br><span class="line">    &#125;);</span><br><span class="line">    res.end(oneNoteHtml);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    next();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, &#123;where: <span class="string">'server'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>到了这里简单的SEO就算是基本完成了。不过目前我的网站权重不是很大，Google的爬取得频率不是很高，baidu基本废了，bing也是。这个就不多说了，我也不在乎。</p>
<h2 id="总结">总结</h2><p>对于单页应用的SEO，做起来还是有些复杂，做更好的SEO那就需要经验了，我这里只是抛砖引玉。<br>本文可以转载，但请保留原始链接.</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Meteor的SEO经验分享</p>
<h2 id="对Meteor_SEO的探索:">对Meteor SEO的探索:</h2><p>在<a href="http://www.itodo.me/u/p/detail/cTqYKYJbfLPs3kR6Y">这篇文章</a>里我就已经对Meteor的SEO做了一次<br>探索性的总结，因为目前很多老外或者官网都推荐<a href="https://atmospherejs.com/meteor/spiderable">这个spideable</a>包，我刚开始也跟着 官网的推荐尝试了一下，各种坑啊，那个<code>phantomjs</code>在这里做为后端编译然后<br>返回<code>html</code>给爬虫，简直是大材小用，更为主要的是，这个<code>phantomjs</code>太大了，而且我没有编译成功，这也是导致我放弃的原因，因为我们要解决meteor 的seo的根本思想就是，后端将渲染好的页面返回给爬虫。本着这个思想，我在<a href="https://atmospherejs.com">package官网</a>也找了一下，最终找到了我想要的包也就是<a href="https://atmospherejs.com/meteorhacks/ssr">srr</a>. 这哥们的源码我也看了，几乎是基于<code>Meteor</code>内在的代码，对其它代码的依赖很小，这才是我想要的。</p>]]>
    
    </summary>
    
      <category term="Meteor.js" scheme="http://strucoder.com/tags/Meteor-js/"/>
    
      <category term="SEO" scheme="http://strucoder.com/tags/SEO/"/>
    
  </entry>
  
</feed>
